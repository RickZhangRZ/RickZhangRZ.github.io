<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-06-27T14:09:30.331Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-27T13:54:16.000Z</published>
    <updated>2021-06-27T14:09:30.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现跨域的标识"><a href="#出现跨域的标识" class="headerlink" title="出现跨域的标识"></a>出现跨域的标识</h2><p>当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</p><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。<br>常见的跨域：<br><img src="http://qval5nqsx.hn-bkt.clouddn.com/image.png" alt="images"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置  Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略，设置响应头中的参数来允许跨域域请求:</p><ol><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Origin 标识允许跨域的请求有哪些<br>例如在java开发中常常这样来解决：</li><li>在POM文件中引入依赖和在web.xml中配置跨域filter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入POM文件 --&gt;</span><br><span class="line">&lt;!-- 解决跨域问题所需依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 在web.xml中配置跨域filter --&gt;</span><br><span class="line">&lt;!--配置跨域过滤器--&gt;</span><br><span class="line">  &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">thetransactioncompany</span>.<span class="title">cors</span>.<span class="title">CORSFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">corsFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>直接导入java类来进行解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(CorsConfiguration.ALL)</span><br><span class="line">                .allowedMethods(CorsConfiguration.ALL)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 1小时内不需要再预检（发OPTIONS请求）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;出现跨域的标识&quot;&gt;&lt;a href=&quot;#出现跨域的标识&quot; class=&quot;headerlink&quot; title=&quot;出现跨域的标识&quot;&gt;&lt;/a&gt;出现跨域的标识&lt;/h2&gt;&lt;p&gt;当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Cont</summary>
      
    
    
    
    
    <category term="前后端交互" scheme="www.rickzhang.cn/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-27-141-环形链表</title>
    <link href="www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-27T13:42:07.000Z</published>
    <updated>2021-06-27T13:42:07.893Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>2021-06-26-02-两数相加</title>
    <link href="www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-06-26T02:49:53.000Z</published>
    <updated>2021-06-26T05:26:26.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因： <span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历两个链表使用数学思维分别转成证书，再进行求和，最后将所求和转为链表(不可取)</li><li>升级版：利用数学思维遍历两个链表，将对应的节点数值进行相加，将结果插入新链表尾部，若数值大于10，则进位，将进位加到下一个节点。<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p = l1, q = l2; <span class="comment">//原链表的两个遍历指针</span></span><br><span class="line">        ListNode resultHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//结果链表的头结点head</span></span><br><span class="line">        ListNode curr = resultHead; <span class="comment">//结果链表的遍历指针，代表当前操作的节点</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点值，如果链表较短，已无节点，取0</span></span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y; <span class="comment">//对应位置节点数值相加</span></span><br><span class="line">            carry = sum / <span class="number">10</span>; <span class="comment">//求进位值，即对10求整</span></span><br><span class="line">            <span class="keyword">int</span> num = sum % <span class="number">10</span>;<span class="comment">//存放到新链表的数值</span></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(num);<span class="comment">//创建新节点存储值</span></span><br><span class="line">            curr = curr.next; <span class="comment">//结果链表向后移动</span></span><br><span class="line">            <span class="comment">//遍历原链表</span></span><br><span class="line">            p = p == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line">            q = q == <span class="keyword">null</span> ? q : q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4.复杂度分析"></a>4.复杂度分析</h2></li><li>时间复杂度：O(max(m,n))</li><li>空间复杂度：O(max(m,n))</li></ul><p><img src="http://qval5nqsx.hn-bkt.clouddn.com/02.jpg" alt="images"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021.06.25|933.最近的请求次数</title>
    <link href="www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/"/>
    <id>www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</id>
    <published>2021-06-25T01:23:24.000Z</published>
    <updated>2021-06-26T02:55:41.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时<br>间（毫秒），返回从 3000 毫秒前（时间范围：[t - 3000, t] ）到现在的 ping 数<br>• 保证每次对 ping 的调用都使用比之前更大的 t 值，1 &lt;= t &lt;= 10^9<br>• 每个测试用例会使用严格递增的 t 值来调用ping，最多调用 10000 次 ping<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inputs = [[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>该题目可以这样理解，最终是要求请求的次数，每次一个请求过来，如果符合([t-3000],t),则记录次数，不符合则不记录，则可以用队列来实现</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q; <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.add(t); <span class="comment">//将请求添加到队列</span></span><br><span class="line">        <span class="comment">//对请求进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (q.peek() &lt; t - <span class="number">3000</span>&gt;) &#123;</span><br><span class="line">            q.poll(); <span class="comment">//不符合则出列</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size(); <span class="comment">//返回总的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析："><a href="#4-复杂度分析：" class="headerlink" title="4. 复杂度分析："></a>4. 复杂度分析：</h2><ul><li>时间复杂度：O(1) //每次添加删除都是O(1)</li><li>空间复杂度: O(1) //最多保留3001个</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时&lt;br</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>小型项目部署篇</title>
    <link href="www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/</id>
    <published>2021-06-24T14:56:19.000Z</published>
    <updated>2021-06-25T01:49:46.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字</strong> 域名 服务器 nginx 代理</p><h4 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h4><ul><li>推荐网站：华为云、阿里云（本人选择）<h4 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a>服务器购买</h4></li><li>推荐网站：华为云、阿里云（本人选择）<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line">service nginx start &#x2F;&#x2F;启动nginx</span><br><span class="line">systemctl enable nginx &#x2F;&#x2F;开启自启</span><br></pre></td></tr></table></figure>安装完nginx后，它的配置文件在/etc/nginx中，打开/etc/nginx/nginx.conf,将user nginx改为user root，保存，不然后续部署项目可能会遇到问题。<h4 id="前端项目打包"><a href="#前端项目打包" class="headerlink" title="前端项目打包"></a>前端项目打包</h4></li><li>打包上传到服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署前端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1000</span>;  <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki.xiaozhang233.top; <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">alias</span> /root/wiki/web/; <span class="comment">#项目路径</span></span><br><span class="line">    <span class="attribute">index</span> index.html; <span class="comment">#首页访问 </span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure><h4 id="JAVA后端项目打包"><a href="#JAVA后端项目打包" class="headerlink" title="JAVA后端项目打包"></a>JAVA后端项目打包</h4></li><li>后端项目打包完成后上传至服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署后端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1001</span>; <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki_server.xiaozhang233.top;  <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8880;<span class="comment">#反向代理，端口号为后端项目运行的端口号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure></li><li>启动JAVA后端项目<br>选择自己想要的目录，创建deploy.sh文件,文件内容为：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "publish----------"</span><br><span class="line"></span><br><span class="line">process_id=`ps -ef | grep edu-zhang.jar | grep -v grep |awk '&#123;print $2&#125;'`</span><br><span class="line">if [ $process_id ] ; then</span><br><span class="line">sudo kill -9 $process_id</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">nohup java -jar -Dspring.profiles.active=prod ~/edu-zhang/edu-zhang.jar &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "end publish"</span><br></pre></td></tr></table></figure></li><li><em>~/edu-zhang/edu-zhang.jar*</em>为自己项目的地址</li><li>执行：sh deploy.sh 启动项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt; 域名 服务器 nginx 代理&lt;/p&gt;
&lt;h4 id=&quot;域名购买&quot;&gt;&lt;a href=&quot;#域名购买&quot; class=&quot;headerlink&quot; title=&quot;域名购买&quot;&gt;&lt;/a&gt;域名购买&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;推荐网站：华为云、阿里云</summary>
      
    
    
    
    
    <category term="项目部署" scheme="www.rickzhang.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-24-07-整数反转</title>
    <link href="www.rickzhang.cn/2021/06/24/2021-06-24-07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>www.rickzhang.cn/2021/06/24/2021-06-24-07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2021-06-24T05:29:07.000Z</published>
    <updated>2021-06-27T13:30:39.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出一个 32 位的有符号整数，将这个整数每位上的数字进行反转</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：-<span class="number">123</span></span><br><span class="line">输出：-<span class="number">321</span>  <span class="comment">//符号不变</span></span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span> <span class="comment">//首位非0;数值溢出返回0;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，将这个整数每位上的数字进行反转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>mysql安装篇</title>
    <link href="www.rickzhang.cn/2021/06/23/mysql%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/06/23/mysql%E5%AE%89%E8%A3%85%E7%AF%87/</id>
    <published>2021-06-23T09:00:06.000Z</published>
    <updated>2021-06-23T09:08:31.300Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载mysql</li><li>进行安装</li><li>配置</li><li>食用</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;下载mysql&lt;/li&gt;
&lt;li&gt;进行安装&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;li&gt;食用&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
    <category term="软件安装" scheme="www.rickzhang.cn/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>常见API(上)</title>
    <link href="www.rickzhang.cn/2020/05/31/%E5%B8%B8%E8%A7%81API-%E4%B8%8A/"/>
    <id>www.rickzhang.cn/2020/05/31/%E5%B8%B8%E8%A7%81API-%E4%B8%8A/</id>
    <published>2020-05-31T12:10:38.000Z</published>
    <updated>2020-05-31T12:18:55.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><a id="more"></a><h3 id="1-1API概述【理解】"><a href="#1-1API概述【理解】" class="headerlink" title="1.1API概述【理解】"></a>1.1API概述【理解】</h3><ul><li><p>什么是API</p><p>​    API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p>​    指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h3 id="1-2如何使用API帮助文档【应用】"><a href="#1-2如何使用API帮助文档【应用】" class="headerlink" title="1.2如何使用API帮助文档【应用】"></a>1.2如何使用API帮助文档【应用】</h3><ul><li>打开帮助文档</li></ul><p><img src="img%5C01.png" alt=""></p><ul><li>找到索引选项卡中的输入框</li></ul><p><img src="img%5C02.png" alt=""></p><ul><li>在输入框中输入Random</li></ul><p><img src="img%5C03.png" alt=""></p><ul><li>看类在哪个包下</li></ul><p><img src="img%5C04.png" alt=""></p><ul><li>看类的描述</li></ul><p><img src="img%5C05.png" alt=""></p><ul><li>看构造方法</li></ul><p><img src="img%5C06.png" alt=""></p><ul><li>看成员方法</li></ul><p><img src="img%5C07.png" alt=""></p><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述【理解】"><a href="#2-1String类概述【理解】" class="headerlink" title="2.1String类概述【理解】"></a>2.1String类概述【理解】</h3><p>​    String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点【理解】"><a href="#2-2String类的特点【理解】" class="headerlink" title="2.2String类的特点【理解】"></a>2.2String类的特点【理解】</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法【记忆】"><a href="#2-3String类的构造方法【记忆】" class="headerlink" title="2.3String类的构造方法【记忆】"></a>2.3String类的构造方法【记忆】</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public   String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s =   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public String()：创建一个空白字符串对象，不含有任何内容</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String();</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(chs);</span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(bys);</span><br><span class="line">        System.out.println(<span class="string">"s3:"</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = “abc”;直接赋值的方式创建字符串对象，内容就是abc</span></span><br><span class="line">        String s4 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(<span class="string">"s4:"</span> + s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4创建字符串对象两种方式的区别【理解】"><a href="#2-4创建字符串对象两种方式的区别【理解】" class="headerlink" title="2.4创建字符串对象两种方式的区别【理解】"></a>2.4创建字符串对象两种方式的区别【理解】</h3><ul><li><p>通过构造方法创建</p><p>​    通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p>​    以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ul><h3 id="2-5字符串的比较【理解】"><a href="#2-5字符串的比较【理解】" class="headerlink" title="2.5字符串的比较【理解】"></a>2.5字符串的比较【理解】</h3><h4 id="2-5-1-号的作用"><a href="#2-5-1-号的作用" class="headerlink" title="2.5.1==号的作用"></a>2.5.1==号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h4 id="2-5-2equals方法的作用"><a href="#2-5-2equals方法的作用" class="headerlink" title="2.5.2equals方法的作用"></a>2.5.2equals方法的作用</h4><ul><li><p>方法介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String s)</span>     比较两个字符串内容是否相同、区分大小写</span></span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法的方式得到对象</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(chs);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接赋值的方式得到对象</span></span><br><span class="line">        String s3 = <span class="string">"abc"</span>;</span><br><span class="line">        String s4 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串对象地址是否相同</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6用户登录案例【应用】"><a href="#2-6用户登录案例【应用】" class="headerlink" title="2.6用户登录案例【应用】"></a>2.6用户登录案例【应用】</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​    已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line"><span class="comment">        2:键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line"><span class="comment">        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line">        String username = <span class="string">"itheima"</span>;</span><br><span class="line">        String password = <span class="string">"czbk"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">            String name = sc.nextLine();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">            String pwd = sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(username) &amp;&amp; pwd.equals(password)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>-i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"你的账户被锁定，请与管理员联系"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//2,1,0</span></span><br><span class="line">                    <span class="comment">//i,0,1,2</span></span><br><span class="line">                    System.out.println(<span class="string">"登录失败，你还有"</span> + (<span class="number">2</span> - i) + <span class="string">"次机会"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7遍历字符串案例【应用】"><a href="#2-7遍历字符串案例【应用】" class="headerlink" title="2.7遍历字符串案例【应用】"></a>2.7遍历字符串案例【应用】</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​    键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:遍历字符串，首先要能够获取到字符串中的每一个字符</span></span><br><span class="line"><span class="comment">            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">        3:遍历字符串，其次要能够获取到字符串的长度</span></span><br><span class="line"><span class="comment">            public int length()：返回此字符串的长度</span></span><br><span class="line"><span class="comment">            数组的长度：数组名.length</span></span><br><span class="line"><span class="comment">            字符串的长度：字符串对象.length()</span></span><br><span class="line"><span class="comment">        4:遍历字符串的通用格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            System.out.println(line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8统计字符次数案例【应用】"><a href="#2-8统计字符次数案例【应用】" class="headerlink" title="2.8统计字符次数案例【应用】"></a>2.8统计字符次数案例【应用】</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​    键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line"><span class="comment">        3:遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="comment">        4:判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line"><span class="comment">            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可</span></span><br><span class="line"><span class="comment">            大写字母：ch&gt;='A' &amp;&amp; ch&lt;='Z'</span></span><br><span class="line"><span class="comment">            小写字母： ch&gt;='a' &amp;&amp; ch&lt;='z'</span></span><br><span class="line"><span class="comment">            数字： ch&gt;='0' &amp;&amp; ch&lt;='9'</span></span><br><span class="line"><span class="comment">        5:输出三种类型的字符个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line">        <span class="keyword">int</span> bigCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> smallCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = line.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'A'</span> &amp;&amp; ch&lt;=<span class="string">'Z'</span>) &#123;</span><br><span class="line">                bigCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>) &#123;</span><br><span class="line">                smallCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                numberCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出三种类型的字符个数</span></span><br><span class="line">        System.out.println(<span class="string">"大写字母："</span> + bigCount + <span class="string">"个"</span>);</span><br><span class="line">        System.out.println(<span class="string">"小写字母："</span> + smallCount + <span class="string">"个"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数字："</span> + numberCount + <span class="string">"个"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9字符串拼接案例【应用】"><a href="#2-9字符串拼接案例【应用】" class="headerlink" title="2.9字符串拼接案例【应用】"></a>2.9字符串拼接案例【应用】</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​    定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​    并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">                s += <span class="string">", "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10字符串反转案例【应用】"><a href="#2-10字符串反转案例【应用】" class="headerlink" title="2.10字符串反转案例【应用】"></a>2.10字符串反转案例【应用】</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​    定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​    例如，键盘录入 abc，输出结果 cba</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = reverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line">        String ss = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ss += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11帮助文档查看String常用方法【记忆】"><a href="#2-11帮助文档查看String常用方法【记忆】" class="headerlink" title="2.11帮助文档查看String常用方法【记忆】"></a>2.11帮助文档查看String常用方法【记忆】</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   equals(Object anObject)</td><td>比较字符串的内容，严格区分大小写(用户名和密码)</td></tr><tr><td>public char charAt(int   index)</td><td>返回指定索引处的 char 值</td></tr><tr><td>public int   length()</td><td>返回此字符串的长度</td></tr></tbody></table><h2 id="3-StringBuilder类"><a href="#3-StringBuilder类" class="headerlink" title="3.StringBuilder类"></a>3.StringBuilder类</h2><h3 id="3-1StringBuilder类概述【理解】"><a href="#3-1StringBuilder类概述【理解】" class="headerlink" title="3.1StringBuilder类概述【理解】"></a>3.1StringBuilder类概述【理解】</h3><p>​    StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的</p><h3 id="3-2StringBuilder类和String类的区别【理解】"><a href="#3-2StringBuilder类和String类的区别【理解】" class="headerlink" title="3.2StringBuilder类和String类的区别【理解】"></a>3.2StringBuilder类和String类的区别【理解】</h3><ul><li>String类：内容是不可变的</li><li>StringBuilder类：内容是可变的</li></ul><h3 id="3-3StringBuilder类的构造方法【记忆】"><a href="#3-3StringBuilder类的构造方法【记忆】" class="headerlink" title="3.3StringBuilder类的构造方法【记忆】"></a>3.3StringBuilder类的构造方法【记忆】</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr><td>public StringBuilder(String   str)</td><td>根据字符串的内容，来创建可变字符串对象</td></tr></tbody></table></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"sb.length():"</span> + sb.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"sb2:"</span> + sb2);</span><br><span class="line">        System.out.println(<span class="string">"sb2.length():"</span> + sb2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4StringBuilder类添加和反转方法【记忆】"><a href="#3-4StringBuilder类添加和反转方法【记忆】" class="headerlink" title="3.4StringBuilder类添加和反转方法【记忆】"></a>3.4StringBuilder类添加和反转方法【记忆】</h3><ul><li><p>添加和反转方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder   append(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr><td>public StringBuilder   reverse()</td><td>返回相反的字符序列</td></tr></tbody></table></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder append(任意类型)：添加数据，并返回对象本身</span></span><br><span class="line"><span class="comment">//        StringBuilder sb2 = sb.append("hello");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("sb:" + sb);</span></span><br><span class="line"><span class="comment">//        System.out.println("sb2:" + sb2);</span></span><br><span class="line"><span class="comment">//        System.out.println(sb == sb2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sb.append("hello");</span></span><br><span class="line"><span class="comment">//        sb.append("world");</span></span><br><span class="line"><span class="comment">//        sb.append("java");</span></span><br><span class="line"><span class="comment">//        sb.append(100);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        sb.append(<span class="string">"hello"</span>).append(<span class="string">"world"</span>).append(<span class="string">"java"</span>).append(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder reverse()：返回相反的字符序列</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5StringBuilder和String相互转换【应用】"><a href="#3-5StringBuilder和String相互转换【应用】" class="headerlink" title="3.5StringBuilder和String相互转换【应用】"></a>3.5StringBuilder和String相互转换【应用】</h3><ul><li><p>StringBuilder转换为String</p><p>​        public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String</p></li><li><p>String转换为StringBuilder</p><p>​        public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //StringBuilder 转换为 String</span></span><br><span class="line"><span class="comment">        StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">        sb.append("hello");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //String s = sb; //这个是错误的做法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String</span></span><br><span class="line"><span class="comment">        String s = sb.toString();</span></span><br><span class="line"><span class="comment">        System.out.println(s);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 转换为 StringBuilder</span></span><br><span class="line">        String s = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder sb = s; //这个是错误的做法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6字符串拼接升级版案例【应用】"><a href="#3-6字符串拼接升级版案例【应用】" class="headerlink" title="3.6字符串拼接升级版案例【应用】"></a>3.6字符串拼接升级版案例【应用】</h3><h4 id="3-6-1案例需求"><a href="#3-6-1案例需求" class="headerlink" title="3.6.1案例需求"></a>3.6.1案例需求</h4><p>​    定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​    并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="3-6-2代码实现"><a href="#3-6-2代码实现" class="headerlink" title="3.6.2代码实现"></a>3.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        String s = sb.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7字符串反转升级版案例【应用】"><a href="#3-7字符串反转升级版案例【应用】" class="headerlink" title="3.7字符串反转升级版案例【应用】"></a>3.7字符串反转升级版案例【应用】</h3><h4 id="3-7-1案例需求"><a href="#3-7-1案例需求" class="headerlink" title="3.7.1案例需求"></a>3.7.1案例需求</h4><p>​    定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​    例如，键盘录入abc，输出结果 cba</p><h4 id="3-7-2代码实现"><a href="#3-7-2代码实现" class="headerlink" title="3.7.2代码实现"></a>3.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中用StringBuilder实现字符串的反转，并把结果转成String返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = myReverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中用StringBuilder实现字符串的反转，并把结果转成String返回</span></span><br><span class="line">        <span class="comment">//String --- StringBuilder --- reverse() --- String</span></span><br><span class="line"><span class="comment">//        StringBuilder sb = new StringBuilder(s);</span></span><br><span class="line"><span class="comment">//        sb.reverse();</span></span><br><span class="line"><span class="comment">//        String ss = sb.toString();</span></span><br><span class="line"><span class="comment">//        return ss;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8帮助文档查看StringBuilder常用方法【记忆】"><a href="#3-8帮助文档查看StringBuilder常用方法【记忆】" class="headerlink" title="3.8帮助文档查看StringBuilder常用方法【记忆】"></a>3.8帮助文档查看StringBuilder常用方法【记忆】</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   StringBuilder append (任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr><td>public   StringBuilder reverse()</td><td>返回相反的字符序列</td></tr><tr><td>public   int   length()</td><td>返回长度，实际存储值</td></tr><tr><td>public   String toString()</td><td>通过toString()就可以实现把StringBuilder转换为String</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-API&quot;&gt;&lt;a href=&quot;#1-API&quot; class=&quot;headerlink&quot; title=&quot;1.API&quot;&gt;&lt;/a&gt;1.API&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="www.rickzhang.cn/2020/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>www.rickzhang.cn/2020/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-05T12:59:34.000Z</published>
    <updated>2020-05-05T13:10:27.992Z</updated>
    
    <content type="html"><![CDATA[<p>对于二叉树，你了解多少？</p><a id="more"></a><h2 id="对于二叉树，你应该了解这些名词"><a href="#对于二叉树，你应该了解这些名词" class="headerlink" title="对于二叉树，你应该了解这些名词"></a>对于二叉树，你应该了解这些名词</h2><ul><li>节点、根节点、父节点、子节点、兄弟节点</li><li>一棵树可以没有任何节点，成为空数</li><li>一棵树可以只有1个节点，也就是只有根节点</li><li>子树、左子树、右子树</li><li>节点的度：子树的个数</li><li>树的度：所有节点度中的最大值</li><li>叶子节点：度为0的节点</li><li>非叶子节点：度不为0的节点</li><li>层数：根节点在第 1 层，根节点的子节点在第 2 层</li><li>节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数</li><li>树的深度：所有节点深度中的最大值</li><li>节点的高度：从当前节点到最远叶子节点的路径上的节点总数</li><li>树的高度：所以节点高度中的最大值</li><li>树的深度 == 树的高度<h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2></li><li>有序树：树中任意节点的子节点之间有顺序关系</li><li>无序树：数中任意节点的子节点之间没有顺序关系，也成“自由树”</li><li>森林：由m（m &gt;= 0）棵互不相交的树组成的集合<h2 id="接下来就是重点了–二叉树"><a href="#接下来就是重点了–二叉树" class="headerlink" title="接下来就是重点了–二叉树"></a>接下来就是重点了–二叉树</h2><ol><li>特点：</li></ol></li><li>每个节点的度最大为2（最多拥有2棵子树）</li><li>左子树和右子树是有顺序的</li><li>即使某节点只有一棵子树，也要区分左右子树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉树是有序树还是无序树？</span><br><span class="line">有序树</span><br></pre></td></tr></table></figure><ol start="2"><li>性质：</li></ol></li><li>非空二叉树的第i层，最多有2的（i-1）次幂个节点（i &gt;= 1）</li><li>在高度为h的二叉树上最多有（2的（h）次幂）-1个节点（h &gt;= 1）</li><li>对于任何一棵非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有：n0 = n2 + 1</li><li>假设度为1的节点个数为n1，那么二叉树的节点总数n = n0 + n1 + n2 - 1,因此n0 = n2 + 1</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于二叉树，你了解多少？&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structures" scheme="www.rickzhang.cn/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>java之旅01</title>
    <link href="www.rickzhang.cn/2020/02/26/java%E4%B9%8B%E6%97%8501/"/>
    <id>www.rickzhang.cn/2020/02/26/java%E4%B9%8B%E6%97%8501/</id>
    <published>2020-02-26T13:36:39.000Z</published>
    <updated>2020-02-26T13:42:42.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java之旅01"><a href="#java之旅01" class="headerlink" title="java之旅01"></a>java之旅01</h1><a id="more"></a><p>字符串常量：要用双引号引起来<br>空常量不能直接打印出来<br>变量：内容可以变的量，定义格式跟C语言一样<br>对于float和long类型来说，字母后缀F和L不要丢掉。<br>没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。<br>/*<br>当数据类型不一样时，将会发生数据类型转换。</p><p>自动类型转换（隐式）<br>    1. 特点：代码不需要进行特殊处理，自动完成。<br>    2. 规则：数据范围从小到大。</p><p>强制类型转换（显式）<br><em>/<br>/</em><br>强制类型转换<br>    1. 特点：代码需要进行特殊的格式处理，不能自动完成。<br>    2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</p><p>注意事项：<br>    1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。<br>    2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.<br>    3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。<br>    4. boolean类型不能发生数据类型转换<br><em>/<br>eg：double–&gt;int 小数点直接舍弃，而非四舍五入<br>一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字<br>一般进行加减法时，无论是short，byte，都会自动转化为int类型再进行加减<br>/</em><br>数字和字符的对照关系表（编码表）：</p><p>ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。<br>Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</p><p>48 - ‘0’<br>65 - ‘A’<br>97 - ‘a’<br><em>/<br>运算符：+—</em>/%  除法用的是整数之间的，只看商，不看余数，%—》只有对于整数的出发来说，取模运算才有余数的意义<br>变量之间进行相加减时，会首先转化为定变量的数据类型在再进行计算<br>/*<br>四则运算当中的加号“+”有常见的三种用法：</p><ol><li>对于数值来说，那就是加法。</li><li>对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。<br>char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode</li><li>对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。<br>任何数据类型和字符串进行连接的时候，结果都会变成字符串</li></ol><p>*/<br>++ 与 –的用法<br>一般分为单独使用和混合使用，单独使用没什么特别注意的，该+的+，该-的-<br>混合使用则值得注意：1)如果是++num，则会先加再进行使用   —-先加后用<br>                  2)如果是num++，则先使用变量本来的值，再执行+   —–先用后加<br>赋值运算符：基本赋值和复合赋值   复合赋值运算符其中隐含了一个强制类型转换。<br>byte num = 30;<br>        // num = num + 5;<br>        // num = byte + int<br>        // num = int + int<br>        // num = int<br>        // num = (byte) int<br>        num += 5;<br>        System.out.println(num); // 35<br>逻辑运算符：与&amp;&amp;  或|| 非！<br>一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反!、自增++、自减–<br>二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=<br>三元运算符：需要三个数据才可以进行操作的运算符。</p><p>格式：<br>数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;</p><p>流程：<br>首先判断条件是否成立：<br>    如果成立为true，那么将表达式A的值赋值给左侧的变量；<br>    如果不成立为false，那么将表达式B的值赋值给左侧的变量；<br>二者选其一。</p><p>注意事项：</p><ol><li><p>必须同时保证表达式A和表达式B都符合左侧数据类型的要求。</p></li><li><p>三元运算符的结果必须被使用。<br>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，<br>那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。</p></li><li><p>如果没有超过左侧的范围，编译器补上强转。</p></li><li><p>如果右侧超过了左侧范围，那么直接编译器报错。</p></li></ol><p>/*<br>在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，<br>那么编译器javac将会直接将若干个常量表达式计算得到结果。<br>short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算<br>编译之后，得到的.class字节码文件当中相当于【直接就是】：<br>short result = 13;<br>右侧的常量结果数值，没有超过左侧范围，所以正确。</p><p>这称为“编译器的常量优化”。</p><p>但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。<br>*/<br>====================================================================<br>方法的命名规则和变量名一样，使用小驼峰，类名使用大驼峰<br>格式：  public static void 方法名称(){<br>    方法体<br>}<br>方法的定义不能产生嵌套包含关系。要使用方法需进行调用(跟C语言的函数调用一样的道理)–调用格式：方法名称（）</p><p>====================================================================<br>顺序结构<br>if   if-else switch<br>switch后面小括号当中只能是下列数据类型：<br>基本数据类型：byte/short/char/int<br>引用数据类型：String字符串、enum枚举<br>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。<br>“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”</p><p>循环结构的基本组成部分：初始化语句、条件判断、循环体、步进语句<br>for<br>while<br>do-while<br>三种循环的区别。</p><ol><li><p>如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。</p></li><li><p>for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环<br>break关键字的用法有常见的两种：</p></li><li><p>可以用在switch语句当中，一旦执行，整个switch语句立刻结束。</p></li><li><p>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</p></li></ol><p>关于循环的选择，有一个小建议：<br>凡是次数确定的场景多用for循环；否则多用while循环。<br>continue：另一种循环控制语句是continue关键字。<br>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。</p><p>常见死循环：while(true){<br>    循环体<br>}</p><h1 id="方法"><a href="#方法" class="headerlink" title="=====方法===="></a>=====方法====</h1><p>方法不能嵌套，必须调用才能使用到它<br>方法格式：<br>修饰符 返回值类型 方法名称（参数类型 参数名称） {</p><pre><code>方法体return返回值；</code></pre><p>}<br>修饰符：现阶段的固定写法，public static<br>返回值类型：也就是方法最终产生的数据结果是什么类型<br>方法名称：方法的名字，规则和变量一样，小驼峰<br>参数类型：进入方法的数据是什么类型<br>参数名称：进入方法的数据对应的变量名称<br>PS：参数如果有多个，使用逗号进行分隔<br>方法体：方法需要做的事情，若干行代码<br>return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处<br>返回值：也就是方法执行后最终产生的数据结果</p><p>注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。<br>方法的三种调用格式：<br>1单独调用2打印调用3赋值调用<br>当返回类型为void时，只能单独调用，不能进行打印调用或者赋值调用<br>====如何判断方法是否需要参数0–<br>有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。<br>例如两个数字相加，必须知道两个数字是各自多少，才能相加。</p><p>无参数：小括号当中留空。一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。<br>例如定义一个方法，打印固定10次HelloWorld。</p><p>定义一个方法常用思路：<br>返回值类型、方法名称、参数列表</p><p>=======使用方法注意事项=====</p><ol><li>方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。</li><li>方法定义的前后顺序无所谓。</li><li>方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。</li><li>如果方法有返回值，那么必须写上“return 返回值;”，不能没有。</li><li>return后面的返回值数据，必须和方法的返回值类型，对应起来。</li><li>对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。</li><li>对于void方法当中最后一行的return可以省略不写。</li><li>一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。</li></ol><p>======方法重载======<br>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称，太麻烦。<br>方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。<br>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。<br>方法重载与下列因素相关：</p><ol><li>参数个数不同</li><li>参数类型不同</li><li>参数的多类型顺序不同</li></ol><p>方法重载与下列因素无关：</p><ol><li>与参数的名称无关</li><li>与方法的返回值类型无关</li></ol><p>在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。</p><h1 id="进入数组"><a href="#进入数组" class="headerlink" title="=====进入数组===="></a>=====进入数组====</h1><p>int[] array = new ing[5];<br>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol><li>数组是一种引用数据类型</li><li>数组当中的多个数据，类型必须统一</li><li>数组的长度在程序运行期间不可改变</li></ol><p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p><p>两种常见的初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><p>动态初始化数组的格式：<br>数据类型[] 数组名称 = new 数据类型[数组长度];</p><p>解析含义：<br>左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型<br>左侧的中括号：代表我是一个数组<br>左侧数组名称：给数组取一个名字<br>右侧的new：代表创建数组的动作<br>右侧数据类型：必须和左边的数据类型保持一致<br>右侧中括号的长度  ：也就是数组当中，到底可以保存多少个数据，是一个int数字<br>静态初始化基本格式：<br>数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … };<br>静态可省略格式：<br>数据类型【】 数组名称 = {元素1，元素2，。。。。。}<br>动态与静态使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。<br>直接打印数组名称，得到的是数组对应的：内存地址哈希值。<br>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：<br>如果是整数类型，那么默认为0；<br>如果是浮点类型，那么默认为0.0；<br>如果是字符类型，那么默认为’\u0000’；<br>如果是布尔类型，那么默认为false；<br>如果是引用类型，那么默认为null。<br>静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。<br>数组必须进行new初始化才能使用其中的元素。<br>如果只是赋值了一个null，没有进行new创建，<br>那么将会发生：<br>空指针异常 NullPointerException<br>数组可以作为方法的参数。<br>当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。<br>一个方法可以有0、1、多个参数；但是只能有0或者1个返回值，不能有多个返回值。<br>如果希望一个方法当中产生了多个结果数据进行返回，怎么办？<br>解决方案：使用一个数组作为返回值类型即可。</p><h1 id="进入类"><a href="#进入类" class="headerlink" title="====进入类====="></a>====进入类=====</h1><p>类由成员变量(属性）和成员方法（行为）组成<br>成员变量是直接定义在类当中的，在方法外边。<br>成员方法不要写static关键字<br>面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。<br>面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。</p><p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。</p><ol><li><p>导包：也就是指出需要使用的类，在什么位置。<br>import 包名称.类名称;<br>import cn.itcast.day06.demo01.Student;<br>对于和当前类属于同一个包的情况，可以省略导包语句不写。</p></li><li><p>创建，格式：<br>类名称 对象名 = new 类名称();<br>Student stu = new Student();</p></li><li><p>使用，分为两种情况：<br>使用成员变量：对象名.成员变量名<br>使用成员方法：对象名.成员方法名(参数)<br>（也就是，想用谁，就用对象名点儿谁。）</p></li></ol><p>注意事项：<br>如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。<br>例如：<br>成员变量（属性）：<br>    String brand; // 品牌<br>    double price; // 价格<br>    String color; // 颜色<br>成员方法（行为）：<br>    public void call(String who) {} // 打电话<br>    public void sendMessage() {} // 群发短信</p><p>private对成员变量进行修饰<br>一旦使用了private进行修饰，那么本类当中仍然可以随意访问。<br>但是！超出了本类范围之外就不能再直接访问了。</p><p>间接访问private成员变量，就是定义一对儿Getter/Setter方法</p><p>必须叫setXxx或者是getXxx命名规则。<br>对于Getter来说，不能有参数，返回值类型和成员变量对应；<br>对于Setter来说，不能有返回值，参数类型和成员变量对应。<br>例如：<br>public class Person {</p><pre><code>String name; // 姓名private int age; // 年龄public void show() {    System.out.println(&quot;我叫：&quot; + name + &quot;，年龄：&quot; + age);}// 这个成员方法，专门用于向age设置数据public void setAge(int num) {    if (num &lt; 100 &amp;&amp; num &gt;= 9) { // 如果是合理情况        age = num;    } else {        System.out.println(&quot;数据不合理！&quot;);    }}// 这个成员方法，专门私语获取age的数据public int getAge() {    return age;}</code></pre><p>}<br>对于private修饰的变量，必须通过.setage/.getage来赋值或者访问</p><p>局部变量与成员变量的区别;</p><ol><li><p>定义的位置不一样【重点】<br>局部变量：在方法的内部<br>成员变量：在方法的外部，直接写在类当中</p></li><li><p>作用范围不一样【重点】<br>局部变量：只有方法当中才可以使用，出了方法就不能再用<br>成员变量：整个类全都可以通用。</p></li><li><p>默认值不一样【重点】<br>局部变量：没有默认值，如果要想使用，必须手动进行赋值<br>成员变量：如果没有赋值，会有默认值，规则和数组一样</p></li><li><p>内存的位置不一样（了解）<br>局部变量：位于栈内存<br>成员变量：位于堆内存</p></li><li><p>生命周期不一样（了解）<br>局部变量：随着方法进栈而诞生，随着方法出栈而消失<br>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p></li></ol><p>面向对象三大特征：封装、继承、多态。<br>方法就是一种封装、关键字private也是一种封装<br>封装就是将一些细节信息隐藏起来，对于外界不可见。</p><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>如果需要访问本类当中的成员变量，需要使用格式：<br>this.成员变量名</p><p>“通过谁调用的方法，谁就是this。”</p><h1 id="构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。"><a href="#构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。" class="headerlink" title="构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。"></a>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。</h1><p>格式：<br>public 类名称(参数类型 参数名称) {</p><pre><code>方法体</code></pre><p>}</p><p>注意事项：</p><ol><li><p>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</p></li><li><p>构造方法不要写返回值类型，连void都不写</p></li><li><p>构造方法不能return一个具体的返回值</p></li><li><p>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。<br>public Student() {}</p></li><li><p>一旦编写了至少一个构造方法，那么编译器将不再赠送。</p></li><li><p>构造方法也是可以进行重载的。<br>重载：方法名称相同，参数列表不同。</p><h1 id="一个标准的类通常要拥有下面四个组成部分："><a href="#一个标准的类通常要拥有下面四个组成部分：" class="headerlink" title="一个标准的类通常要拥有下面四个组成部分："></a>一个标准的类通常要拥有下面四个组成部分：</h1><ol><li>所有的成员变量都要使用private关键字修饰</li><li>为每一个成员变量编写一对儿Getter/Setter方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><p>这样标准的类也叫做Java Bean</p></li></ol><p>Scanner类的功能：可以实现键盘输入数据，到程序当中。</p><p>引用类型的一般使用步骤：</p><ol><li><p>导包<br>import 包路径.类名称;<br>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。<br>只有java.lang包下的内容不需要导包，其他的包都需要import语句。</p></li><li><p>创建<br>类名称 对象名 = new 类名称();</p></li><li><p>使用<br>对象名.成员方法名()</p></li></ol><p>获取键盘输入的一个int数字：int num = sc.nextInt();<br>获取键盘输入的一个字符串：String str = sc.next();<br>创建类步骤：<br>导包—创建—使用<br>例如： // 备注：System.in代表从键盘进行输入<br>        Scanner sc = new Scanner(System.in);</p><pre><code>// 3. 获取键盘输入的int数字int num = sc.nextInt();System.out.println(&quot;输入的int数字是：&quot; + num);// 4. 获取键盘输入的字符串String str = sc.next();System.out.println(&quot;输入的字符串是：&quot; + str);</code></pre><p>匿名对象：：：<br>创建对象的标准格式：<br>类名称 对象名 = new 类名称();</p><p>匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。<br>new 类名称();</p><p>注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。<br>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。<br>// 普通使用方式<br>//        Scanner sc = new Scanner(System.in);<br>//        int num = sc.nextInt();</p><pre><code>// 匿名对象的方式</code></pre><p>//        int num = new Scanner(System.in).nextInt();<br>//        System.out.println(“输入的是：” + num);</p><pre><code>// 使用一般写法传入参数</code></pre><p>//        Scanner sc = new Scanner(System.in);<br>//        methodParam(sc);</p><pre><code>// 使用匿名对象来进行传参</code></pre><p>//        methodParam(new Scanner(System.in));</p><p>======几种类的学习======<br>一 —Random<br>导包、创建、使用<br>Random r = new Random()<br>int num = r.nextInt(0,3);//可加参数,数字是从0开始算起，如果想生成范围从大于0开始的，可以加上一个数<br>例如生成一个3~5的数，可表示为：<br>int num = r.nextInt(4)+1;</p><p>二 —-集合<br>数组的长度不可以发生改变。<br>但是ArrayList集合的长度是可以随意变化的。</p><p>对于ArrayList来说，有一个尖括号<E>代表泛型。<br>泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。<br>注意：泛型只能是引用类型，不能是基本类型。</p><p>注意事项：<br>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。<br>如果内容是空，得到的是空的中括号：[]<br>ArrayList<Integer> list = new ArrayList&lt;&gt;();<br>list.add(1);<br>ArrayList当中的常用方法有：</p><p>public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。<br>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。<br>但是对于其他集合（今后学习）来说，add添加动作不一定成功。</p><p>public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</p><p>public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</p><p>public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。<br>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</p><p>基本类型    包装类（引用类型，包装类都位于java.lang包下）<br>byte        Byte<br>short       Short<br>int         Integer     【特殊】<br>long        Long<br>float       Float<br>double      Double<br>char        Character   【特殊】<br>boolean     Boolean</p><p>从JDK 1.5+开始，支持自动装箱、自动拆箱。</p><p>自动装箱：基本类型 –&gt; 包装类型<br>自动拆箱：包装类型 –&gt; 基本类型java.lang.String类代表字符串。<br>API当中说：Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）</p><p>字符串的特点：</p><ol><li>字符串的内容永不可变。【重点】</li><li>正是因为字符串不可改变，所以字符串是可以共享使用的。</li><li>字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。</li></ol><p>创建字符串的常见3+1种方式。<br>三种构造方法：<br>public String()：创建一个空白字符串，不含有任何内容。<br>public String(char[] array)：根据字符数组的内容，来创建对应的字符串。<br>public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。<br>一种直接创建：<br>String str = “Hello”; // 右边直接用双引号</p><p>注意：直接写上双引号，就是字符串对象。</p><p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。</p><p>对于基本类型来说，==是进行数值的比较。<br>对于引用类型来说，==是进行【地址值】的比较。</p><p>public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同<br>的才会给true；否则返回false。</p><p>public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。</p><p>String当中与获取相关的常用方法有：</p><p>public int length()：获取字符串当中含有的字符个数，拿到字符串长度。<br>public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。<br>public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）<br>public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</p><p>public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。<br>public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。<br>备注：[begin,end)，包含左边，不包含右边。</p><p>String当中与转换相关的常用方法有：</p><p>public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。<br>public byte[] getBytes()：获得当前字符串底层的字节数组。<br>public String replace(CharSequence oldString, CharSequence newString)：<br>将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。<br>备注：CharSequence意思就是说可以接受字符串类型。</p><p>分割字符串的方法：<br>public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。</p><p>注意事项：<br>split方法的参数其实是一个“正则表达式”，今后学习。<br>今天要注意：如果按照英文句点“.”进行切分，必须写”\.”（两个反斜杠）</p><p>如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。例如：多个人共享一个教室</p><h2 id="一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。"><a href="#一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。" class="headerlink" title="一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。"></a>一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</h2><p>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。<br>如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</p><p>无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。<br>静态变量：类名称.静态变量<br>静态方法：类名称.静态方法()</p><p>注意事项：</p><ol><li><p>静态不能直接访问非静态。<br>原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。<br>“先人不知道后人，但是后人知道先人。”</p></li><li><p>静态方法当中不能用this。<br>原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</p><p>静态代码块的格式是：</p><p>public class 类名称 {<br>   static {</p><pre><code>// 静态代码块的内容</code></pre><p>   }<br>}</p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的典型用途：<br>用来一次性地对静态成员变量进行赋值。</p><p>​</p></li></ol><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</p><p>public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]）<br>public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。</p><p>备注：</p><ol><li>如果是数值，sort默认按照升序从小到大</li><li>如果是字符串，sort默认按照字母升序</li><li>如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习）</li></ol><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</p><p>public static double abs(double num)：获取绝对值。有多种重载。<br>public static double ceil(double num)：向上取整。<br>public static double floor(double num)：向下取整。<br>public static long round(double num)：四舍五入。</p><p>Math.PI代表近似的圆周率常量（double）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java之旅01&quot;&gt;&lt;a href=&quot;#java之旅01&quot; class=&quot;headerlink&quot; title=&quot;java之旅01&quot;&gt;&lt;/a&gt;java之旅01&lt;/h1&gt;</summary>
    
    
    
    
    <category term="java学习" scheme="www.rickzhang.cn/tags/java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机网络模式</title>
    <link href="www.rickzhang.cn/2019/12/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>www.rickzhang.cn/2019/12/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-12-27T12:41:56.000Z</published>
    <updated>2019-12-27T12:49:16.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机网络类型"><a href="#虚拟机网络类型" class="headerlink" title="虚拟机网络类型"></a>虚拟机网络类型</h1><a id="more"></a><p>​         在VMware中，虚拟机的网络连接主要是由VMware创建的虚拟交换机(也叫做虚拟网络)负责实现的，VMware可以根据需要创建多个虚拟网络。在Windows系统的主机上，VMware最多可以创建20个虚拟网络，每个虚拟网络可以连接任意数量的虚拟机网络设备；</p><p>　　在Linux系统的主机上，VMware最多可以创建255个虚拟网络，但每个虚拟网络仅能连接32个虚拟机网络设备。</p><p>VMware的虚拟网络都是以”VMnet+数字”的形式来命名的，例如 VMnet0、VMnet1、VMnet2……以此类推(在Linux系统的主机上，虚拟网络的名称均采用小写形式，例如 vmnet0 )。</p><p>　　当我们安装VMware时，VMware会自动为3种网络连接模式各自创建1个虚拟机网络：VMnet0(桥接模式)、VMnet8(NAT模式)、VMnet1(仅主机模式)。此外，我们也可以根据需要自行创建更多的虚拟网络。</p><h2 id="VMware-桥接模式"><a href="#VMware-桥接模式" class="headerlink" title="VMware 桥接模式"></a>VMware 桥接模式</h2><p>　　VMware桥接模式，也就是将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络(例如图中所示的局域网和Internet，下同)。简而言之，这就好像在上图所示的局域网中添加了一台新的、独立的计算机一样。因此，虚拟机也会占用局域网中的一个IP地址，并且可以和其他终端进行相互访问。桥接模式网络连接支持有线和无线主机网络适配器。如果你想把虚拟机当做一台完全独立的计算机看待，并且允许它和其他终端一样的进行网络通信，那么桥接模式通常是虚拟机访问网络的最简单途径。</p><h2 id="VMware-NAT模式"><a href="#VMware-NAT模式" class="headerlink" title="VMware NAT模式"></a>VMware NAT模式</h2><p>　　NAT，是Network Address Translation的缩写，意即网络地址转换。NAT模式也是VMware创建虚拟机的默认网络连接模式。使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机。</p><p>　　此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的。</p><p>　　前面我们已经提到，默认情况下，外部网络无法访问到虚拟机，不过我们也可以通过手动修改NAT设置实现端口转发功能，将外部网络发送到主机指定端口的数据转发到指定的虚拟机上。比如，我们在虚拟机的80端口上”建立”了一个站点，只要我们设置端口转发，将主机88端口上的数据转发给虚拟机的80端口，就可以让外部网络通过主机的88端口访问到虚拟机80端口上的站点。</p><h2 id="VMware-仅主机模式"><a href="#VMware-仅主机模式" class="headerlink" title="VMware 仅主机模式"></a>VMware 仅主机模式</h2><p>　　仅主机模式，是一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于NAT模式而言，仅主机模式不具备NAT功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。</p><p>　　在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信(可通过在它们之间设置路由器来实现相互通信)。</p><h2 id="自定义网络连接配置"><a href="#自定义网络连接配置" class="headerlink" title="自定义网络连接配置"></a>自定义网络连接配置</h2><p>　　利用 WMware 提供的虚拟网络连接组件，你还可以创建复杂的虚拟网络。在这里我们不对其进行详细介绍，你可以参考官方文档，然后通过VMware提供的虚拟网络编辑器来创建虚拟网络。</p><p>web服务器：负责处理http请求，响应静态文件，常见的有apache,nginx及IIS</p><p>应用服务器：负责处理逻辑的服务器，比如php，python的代码，是不能通过nginx这种web服务器来处理的，只能提供</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;虚拟机网络类型&quot;&gt;&lt;a href=&quot;#虚拟机网络类型&quot; class=&quot;headerlink&quot; title=&quot;虚拟机网络类型&quot;&gt;&lt;/a&gt;虚拟机网络类型&lt;/h1&gt;</summary>
    
    
    
    
    <category term="虚拟机" scheme="www.rickzhang.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>域名解析详解</title>
    <link href="www.rickzhang.cn/2019/12/04/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%AF%A6%E8%A7%A3/"/>
    <id>www.rickzhang.cn/2019/12/04/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-12-04T05:41:36.000Z</published>
    <updated>2019-12-04T05:48:35.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于阿里云域名解析记录填写详解"><a href="#关于阿里云域名解析记录填写详解" class="headerlink" title="关于阿里云域名解析记录填写详解"></a>关于阿里云域名解析记录填写详解</h1><a id="more"></a><p><img src="C:%5CUsers%5Cdell%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20191204131433.jpg" alt="QQ截图20191204131433"></p><h2 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h2><ol><li>A记录：将域名指向一个IPV4地址，需要增加A记录</li><li>CNAME：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录</li><li>MX：建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录</li><li>NS：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录</li><li>TXT记录：可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用</li><li>AAAA记录：将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录</li><li>SRV记录：记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</li><li>显性URL：将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将<a href="http://www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。">www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。</a></li><li>隐性URL：与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将<a href="http://www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。">www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。</a></li></ol><p>例如：A记录常见用于服务器绑定域名</p><p>​           CNAME记录常见于指向github上搭建的服务器</p><h2 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h2><p>常见用法有：</p><p><strong>www：</strong>解析后的域名为<a href="http://www.aliyun.com。" target="_blank" rel="noopener">www.aliyun.com。</a></p><p><strong>@：</strong>直接解析主域名 aliyun.com。</p><p><strong>*：</strong>泛解析，匹配其他所有域名 *.aliyun.com。</p><p><strong>mail：</strong>将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</p><p><strong>二级域名：</strong>如：abc.aliyun.com，填写abc。</p><p><strong>手机网站：</strong>如：m.aliyun.com，填写m。</p><p><strong>显性URL：</strong>不支持泛解析（泛解析：将所有子域名解析到同一地址）</p><p>说到最后发现阿里云的帮助文档比我讲的还详细，哈哈哈，尴尬的一篇博文</p><p>直击阿里云帮助文档：<a href="https://help.aliyun.com/knowledge_detail/29725.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/29725.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于阿里云域名解析记录填写详解&quot;&gt;&lt;a href=&quot;#关于阿里云域名解析记录填写详解&quot; class=&quot;headerlink&quot; title=&quot;关于阿里云域名解析记录填写详解&quot;&gt;&lt;/a&gt;关于阿里云域名解析记录填写详解&lt;/h1&gt;</summary>
    
    
    
    
    <category term="域名解析" scheme="www.rickzhang.cn/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>排序算法大集(后续更新)</title>
    <link href="www.rickzhang.cn/2019/11/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E9%9B%86-%E5%90%8E%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>www.rickzhang.cn/2019/11/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E9%9B%86-%E5%90%8E%E7%BB%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2019-11-28T13:04:20.000Z</published>
    <updated>2019-11-29T05:25:02.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序合集"><a href="#排序合集" class="headerlink" title="排序合集"></a>排序合集</h1><a id="more"></a><ol><li>排序：找最小的，第二小的，不断往左边扔</li><li>插入排序：从后往前找比自己大的前一个位置插入，每次往前挪一格</li><li>希尔排序：插入排序升级版，每次挪n格</li><li>归并排序：先将总的分成两份</li></ol><h2 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;<span class="built_in">array</span>[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="built_in">array</span>[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-2</span>;<span class="built_in">array</span>[j]&gt;<span class="built_in">array</span>[<span class="number">0</span>];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//array[j]&lt;array[0]</span></span><br><span class="line">        <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先从i=2开始往后找，若array[i]&lt;array[i-1],则将array[i]赋值给哨兵，之后便往后寻找合适位置插入。</p><h2 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找第i小的元素，i从0~iArraylen-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; iArrayLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iMinIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; iArrayLen; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[iMinIndex] &gt; <span class="built_in">array</span>[j])</span><br><span class="line">            &#123;</span><br><span class="line">                iMinIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找出最小索引元素后，与第i元素交换</span></span><br><span class="line">        <span class="keyword">if</span>(iMinIndex != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> iTem = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[iMinIndex];</span><br><span class="line">            <span class="built_in">array</span>[iMinIndex] = iTem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从第i个开始往后寻找，将i赋值给iMindex，如果array[iMindex]&gt;array[i+1]，将i+1赋值给iMindex，不断往后比较，直到找到最小值的索引，并赋值给iMindex，最后将array[iMindex]赋值给array[i]</p><h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要两个计量数，两两进行比较,以及进行交换的变量</span></span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j<span class="number">-1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                   temp = <span class="built_in">array</span>[j];</span><br><span class="line">                    <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j<span class="number">-1</span>];</span><br><span class="line">                    <span class="built_in">array</span>[j<span class="number">-1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>l两两进行比较，用两个循环来实现，最简单的排序方法</p><h2 id="两字符串进行复制"><a href="#两字符串进行复制" class="headerlink" title="两字符串进行复制"></a>两字符串进行复制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"china"</span>;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>],*p,*q;</span><br><span class="line">    p = a;</span><br><span class="line">    q = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input n(n&lt;5):"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(a)&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        p+=n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;*p!=<span class="string">'\0'</span>;p++,q++)</span><br><span class="line">        *q = *p;</span><br><span class="line">    *q=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"String a :%s\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"String b :%s\n"</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每个人的编号存放在一个数组 a 中，主函数中决定人数的个数以及报数的上限值 m，设计一个函数实现对应的操作。函数的形参有整型数组 a、整数 n 和 m，n 用来接收传递的人数，m 用来接收报数上限，函数的返回值为空；函数体中输出出列人的顺序。</p><p>函数中利用循环访问数组中 n 个元素，每次访问元素，设定内循环连续访问 m 个元素，元素访问的下标为 k，访问到第 m 个元素时，如果元素不是 0，此时输出元素 a[k]，再设定 a[k] 为 0，继续访问后面的元素。</p><p>主函数中设定数组 a，从键盘输入 n 和 m，利用循环产生 n 的位置序号存放到数组 a 中，调用函数实现相应的操作。</p><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josef</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[k]==<span class="number">0</span>)</span><br><span class="line">            k=(k+<span class="number">1</span>)%n;</span><br><span class="line">            j++;</span><br><span class="line">            k=(k+<span class="number">1</span>)%n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[k]==<span class="number">0</span>)</span><br><span class="line">        k=(k+<span class="number">1</span>)%n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[k]);</span><br><span class="line">        a[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j,m,n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input n and m："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        a[i]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n output：\n"</span>);</span><br><span class="line">    josef(a,n,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;排序合集&quot;&gt;&lt;a href=&quot;#排序合集&quot; class=&quot;headerlink&quot; title=&quot;排序合集&quot;&gt;&lt;/a&gt;排序合集&lt;/h1&gt;</summary>
    
    
    
    
    <category term="data structures and algorithms" scheme="www.rickzhang.cn/tags/data-structures-and-algorithms/"/>
    
  </entry>
  
  <entry>
    <title>三大框架搭建属于你的博客.md</title>
    <link href="www.rickzhang.cn/2019/11/14/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>www.rickzhang.cn/2019/11/14/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-11-14T15:19:33.000Z</published>
    <updated>2020-05-31T12:06:56.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于三大框架"><a href="#基于三大框架" class="headerlink" title="基于三大框架"></a>基于三大框架</h1><a id="more"></a>##博客搭建：基于hugo框架<p>下载安装包-&gt;安装:wget <a href="https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.deb" target="_blank" rel="noopener">https://github.com/gohugoio/hugo/releases/download/v0.54.0/hugo_0.54.0_Linux-64bit.deb</a><br>sudo dpkg -i hugo_0.54.0_Linux-64bit.deb<br>-&gt;用hugo生成博客：hugo new site （myblog）博客名<br>-&gt;设置主题：进入官网：<a href="https://themes.gohugo.io/-&gt;回到myblog目录：git" target="_blank" rel="noopener">https://themes.gohugo.io/-&gt;回到myblog目录：git</a> clone url<br>-&gt;在本地启动个人博客：hugo server -t m10(主题名) –buildDrafts<br>-&gt;回到myblog目录：hugo new post/blog.md(实际写一篇文章)路径位于：myblog/content/post<br>-&gt;回到myblog目录本地启用：hugo server -t m10c –buildDrafts<br>-&gt;部署到github:现在github新建仓库，仓库名为.github.io结尾<br>hugo –theme=m10c –baseUrl=”<a href="https://RickZhangRZ.github.io/&quot;" target="_blank" rel="noopener">https://RickZhangRZ.github.io/&quot;</a> –buildDrafts<br>之后会生成一个public文件<br>进入到public更新到仓库：git init<br>git add .<br>git commit -m “我的hugo博客第一次提交” //更新到仓库<br>-&gt;public与仓库关联：<br>git remote add origin <a href="https://github.com/RickZhangRZ/RickZhangRZ.github.io.git" target="_blank" rel="noopener">https://github.com/RickZhangRZ/RickZhangRZ.github.io.git</a><br>之后推上去：git push -u origin master</p><h2 id="基于docker搭建动态workpress博客"><a href="#基于docker搭建动态workpress博客" class="headerlink" title="基于docker搭建动态workpress博客"></a>基于docker搭建动态workpress博客</h2><p>-&gt;下载安装docker-参考菜鸟教程<br>-&gt;之后配置一个.yml的配置文件：version: ‘3.3’<br>services:<br>   db:<br>     image: mysql:5.7<br>     volumes:<br>       - db_data:/var/lib/mysql<br>     restart: always<br>     environment:<br>       MYSQL_ROOT_PASSWORD: somewordpress<br>       MYSQL_DATABASE: wordpress<br>       MYSQL_USER: wordpress<br>       MYSQL_PASSWORD: wordpress</p><p>   wordpress:<br>     depends_on:<br>       - db<br>     image: wordpress:latest<br>     ports:<br>       - “8000:80”<br>     restart: always<br>     environment:<br>       WORDPRESS_DB_HOST: db:3306<br>       WORDPRESS_DB_USER: wordpress<br>       WORDPRESS_DB_PASSWORD: wordpress<br>       WORDPRESS_DB_NAME: wordpress<br>volumes:<br>    db_data: {}<br>放到博客文件里<br>-&gt;docker-compose up -d一条命令即可搭建(但在不同的操作系统会有各种各样的错误)<br>例如：ubuntu——该命令会出现错误，需要1.进入启动文件目录-将用户加入到到docker组：sudo gpasswd -a ${USER} docker-&gt;sudo su-&gt;su ${USER}-&gt;docker-compose up -d<br>搭建成功切记不要该域名：教训-&gt;目前域名问题还没解决…….</p><h2 id="—基于hexo框架搭建个人博客–在window系统下用cmd"><a href="#—基于hexo框架搭建个人博客–在window系统下用cmd" class="headerlink" title="—基于hexo框架搭建个人博客–在window系统下用cmd"></a>—基于hexo框架搭建个人博客–在window系统下用cmd</h2><ol><li>首先安装node.js环境<ul><li>//-&gt;linux进入root模式：sudo su</li><li>下载hexo-因为国内镜像源下载镜像慢，所以安装淘宝镜像源来进行下载，利用npm<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">mkdir blog</span><br><span class="line">cd blog -&gt; hexo init</span><br><span class="line">hexo s ----启动博客</span><br><span class="line">hexo n &quot;我的第一篇博客.md&quot;</span><br><span class="line">cd cource&#x2F;_posts</span><br><span class="line">deleted database(???)&#x2F;&#x2F;清除缓存</span><br><span class="line">hexo g(生成博客)</span><br><span class="line">hexo s(启动博客)</span><br></pre></td></tr></table></figure></li><li>部署到github–先在github创建一个空仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">需要在blog安装一个插件：cnpm install --save hexo-deployer-git(为后面使用hexo d做铺垫)</span><br><span class="line">-&gt;之后编辑_config.yml:vim ----</span><br><span class="line">  在deployment里：</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;名字&#x2F;.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">-&gt;hexo d(部署到远端)  ---过程需要输入github名字密码(把public里的文件部署到远端)</span><br><span class="line">-&gt;下载主题：git clone URL</span><br><span class="line">-&gt;文件放入theme</span><br><span class="line">-&gt;改_congit.yml---生成启动推</span><br><span class="line">-----&gt;参考:https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;</span><br><span class="line">---&gt;主题修改：</span><br><span class="line">---头像问题：直接把图片放在theme&#x2F;source---&gt;改主题下的_config.yml-&gt;URL:&#x2F;图像名.jpg</span><br><span class="line">---域名问题：直接将CNAME文件置于根目录下source里即可，这样hexo deploy才能将CNAME文件一并推送至部署分支</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基于三大框架&quot;&gt;&lt;a href=&quot;#基于三大框架&quot; class=&quot;headerlink&quot; title=&quot;基于三大框架&quot;&gt;&lt;/a&gt;基于三大框架&lt;/h1&gt;</summary>
    
    
    
    
    <category term="博客搭建" scheme="www.rickzhang.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>not.1.md</title>
    <link href="www.rickzhang.cn/2019/10/25/no-1-md/"/>
    <id>www.rickzhang.cn/2019/10/25/no-1-md/</id>
    <published>2019-10-25T11:09:22.000Z</published>
    <updated>2021-06-23T06:15:49.388Z</updated>
    
    <content type="html"><![CDATA[<p>——很高兴创建了个人博客！！！！hhhhhhhh</p><a id="more"></a>------很高兴创建了个人博客！！！！------很高兴创建了个人博客！！！！<p>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！<br>——很高兴创建了个人博客！！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;——很高兴创建了个人博客！！！！hhhhhhhh&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

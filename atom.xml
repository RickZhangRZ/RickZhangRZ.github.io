<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-07-15T02:15:08.415Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从汉诺塔问题谈到递归</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/</id>
    <published>2021-07-14T10:19:19.000Z</published>
    <updated>2021-07-15T02:15:08.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>根据美国一学者提出的两步操作法：1.按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，2.把另外两根柱子上可以移动的圆盘移动到新的柱子上<br>• 把非空柱子上的圆盘移动到空柱子上<br>• 当两根柱子都非空时，移动较小的圆盘<br>重复以上操作即可，对于N层汉诺塔，有以下思路：• 如果我们能将上面的N-1层移动到B上<br>• 把N层移动到C，再把B上N-1层移动到C上就可以解决问题了<br>• 问题变为如何解决N-1层汉诺塔的移动问题<br>• 继续思考一直到N-1等于1时，我们可以直接将1层汉诺塔移动目的位置<br>可以选择递归来实现：<br>• 递归函数主功能<br>• 移动N-1个盘子到中间柱子<br>• 移动第N个盘子到目标柱子<br>• 将N-1个盘子从中间柱子移动到目标柱<br>子<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        movePlate(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">movePlate</span><span class="params">(<span class="keyword">int</span> size, List&lt;Integer&gt; start, List&lt;Integer&gt; auxiliary,List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 只剩⼀一个盘⼦子时，直接从第⼀一个柱⼦子移动到第三个柱⼦子 即可</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数主功能：移动n-1个盘⼦子，移动第n个盘⼦子，移动n-1个盘⼦子</span></span><br><span class="line">        <span class="comment">// 等价关系式 f(n , A , B , C)=f(n-1,A,C,B)+M(A,C)+f(n-1, B,A,C)</span></span><br><span class="line">        <span class="comment">// 将 n-1 个盘⼦子，从 第⼀一个柱⼦子 移动到 第⼆二个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,start,target,auxiliary);</span><br><span class="line">        <span class="comment">// 将第 n个盘⼦子，从 第⼀一个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 再将 n-1 个盘⼦子，从 第⼆二个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,auxiliary,start,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：通过</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.4 MB, 在所有 Java 提交中击败了45.35%的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="递归" scheme="www.rickzhang.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>你应该懂的排序</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-14T01:45:13.000Z</published>
    <updated>2021-07-14T13:57:16.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[begin] &lt; arr[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[begin];</span><br><span class="line">                arr[begin] = arr[begin - <span class="number">1</span>];</span><br><span class="line">                arr[begin - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n2)</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[j] &gt; temp)) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) arr[j] =temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡排序&quot;&gt;&lt;/a&gt;1. 冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    
    <category term="排序" scheme="www.rickzhang.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>springcloud使用</title>
    <link href="www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/"/>
    <id>www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-10T06:29:39.000Z</published>
    <updated>2021-07-13T06:22:08.158Z</updated>
    
    <content type="html"><![CDATA[<p>nacos注册中心<br>使用方式：<br>1.为项目导入alibaba的依赖<br>2.导入nacos的依赖<br>3.在main加注解<br>4.需要给每一个微服务加上自己的名字</p><p>想要远程调用别的服务<br>1.引入open-feign<br>2.编写一个接口，告诉springcloud这个接口需要调用远程服务<br>3.声明接口的每一个方法都是调用哪个远程服务的那个请求<br>4.开启远程调用功能<br>远程调用注意版本：<a href="https://blog.csdn.net/weixin_45729934/article/details/110310119" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45729934/article/details/110310119</a></p><p>nacos作为配置中心<br>1.导入pom：nacos config starter<br>2.创建配置文件：bootstrap.properties<br>3.在127.0.0.1：8848中创建配置文件：项目名.properties<br>4.在controller加上@RefreshScope—-动态刷新</p><p>API网关</p><p>vue<br>初始化：npm init -y<br>安装vue依赖：npm install vue</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nacos注册中心&lt;br&gt;使用方式：&lt;br&gt;1.为项目导入alibaba的依赖&lt;br&gt;2.导入nacos的依赖&lt;br&gt;3.在main加注解&lt;br&gt;4.需要给每一个微服务加上自己的名字&lt;/p&gt;
&lt;p&gt;想要远程调用别的服务&lt;br&gt;1.引入open-feign&lt;br&gt;2.编写一个</summary>
      
    
    
    
    
    <category term="springcloud" scheme="www.rickzhang.cn/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>线程学习笔记</title>
    <link href="www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T02:52:48.000Z</published>
    <updated>2021-07-13T06:23:17.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享学"><a href="#享学" class="headerlink" title="享学"></a>享学</h2><ol><li>安装完成的软件叫应用程序 是死的<br>打开后叫进程 操作系统分配资源的最小单位<br>进程与进程之间是相互独立<br>线程是CPU调度的最小单位<br>线程必须依赖于进程<br>进程里允许有多个线程<br>线程之间可以共享进程的资源<br>CPU多核数与线程的关系：一对一关系<br>RR调度  CPU时间片轮转机制<br>并行与并发：<br>并行：可以同时运行的任务数<br>并发：讨论并发无法脱离时间，可以交替执行不用任务，<br>创建线程的方式有两种，在官方JDK源码Thread里有写</li><li>继承Thread</li><li>实现Runnable接口<br>两者有什么区别呢？<br>Thread是线程的抽象，Runnable是对任务的抽象<br>stop()方法为什么不建议使用？<br>可能会导致线程所占用的资源不会正常的释放<br>interrupt()是对线程进行中断<br>isInterrupted()是判断线程是否被中断<br>interrupted() 把标志位改为false<br>JDK线程是协作式，不是抢占式</li><li>实现接口Runnable的线程如何进行中断？<br>Thread.currentThread().isInterrupted()</li></ol><h2 id="马士兵"><a href="#马士兵" class="headerlink" title="马士兵"></a>马士兵</h2><p>什么是进程？<br>什么是线程？<br>什么是qia</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;享学&quot;&gt;&lt;a href=&quot;#享学&quot; class=&quot;headerlink&quot; title=&quot;享学&quot;&gt;&lt;/a&gt;享学&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装完成的软件叫应用程序 是死的&lt;br&gt;打开后叫进程 操作系统分配资源的最小单位&lt;br&gt;进程与进程之间是相互独立&lt;br&gt;线程是C</summary>
      
    
    
    
    
    <category term="线程" scheme="www.rickzhang.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从3.无重复字符的最长子串到哈希表</title>
    <link href="www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-07-07T15:06:29.000Z</published>
    <updated>2021-07-07T15:24:32.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>从题目的无重复可以引入哈希表，因为哈希表对于查找是比较快的<br>先定义一个数组来存储</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, <span class="comment">//最长不重复子串的长度</span></span><br><span class="line">        left = <span class="number">0</span>, <span class="comment">//子串最左端字符索引</span></span><br><span class="line">        right = <span class="number">0</span>; <span class="comment">//子串最右端字符索引</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">//ASCII码</span></span><br><span class="line">        <span class="comment">//赋初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历字符串的所有字符</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s.charAt(right);<span class="comment">//取出right对应索引的值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start0 = arr[c] + <span class="number">1</span>;</span><br><span class="line">                left = left &gt;= start0 ? left : start0;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[c] = right;</span><br><span class="line">            <span class="keyword">int</span> size = right + <span class="number">1</span> - left;</span><br><span class="line">            res = res &gt; size ? res : size;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了83.64%的用户</p><p><strong>复杂度分析</strong><br>时间复杂度:O(n)<br>空间复杂度:O(1)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;br&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="www.rickzhang.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>80.删除有序数组中的重复项Ⅱ</title>
    <link href="www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/"/>
    <id>www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/</id>
    <published>2021-07-02T15:40:30.000Z</published>
    <updated>2021-07-02T16:27:44.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>相对于26题目，对了一个条件，只需要多了一个步伐便可<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;<span class="comment">//数组长度</span></span><br><span class="line">    <span class="comment">//如果数组长度小于等于2，则不用进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow-<span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：<br>0 ms<br>, 在所有 Java 提交中击败了<br>100.00%<br>的用户</p><p>内存消耗：<br>38.4 MB<br>, 在所有 Java 提交中击败了<br>79.48%<br>的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。&lt;/p</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>27.移除元素</title>
    <link href="www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-02T11:50:24.000Z</published>
    <updated>2021-07-02T12:14:00.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>目标是如果数组中与给定值相等，等将后面的元素往前移动，如果不相等，则继续遍历数组，定义两个指针，一个(left)负责遍历原数组，一个(right)负责与目标值target比较，若right与val相等，则right++,如果不相等,<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">//原数组指针</span></span><br><span class="line">    <span class="comment">//right为遍历指针,负责与val比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; length; right++) &#123;</span><br><span class="line">        <span class="comment">//如果right与val不相等，则将right赋值给left，left往前走</span></span><br><span class="line">        <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%<br>的用户</p><p>内存消耗：36.8 MB, 在所有 Java 提交中击败了85.41%的用户</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>从26.删除有序数组中的重复项谈到双指针</title>
    <link href="www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-07-02T09:39:50.000Z</published>
    <updated>2021-07-02T11:49:17.591Z</updated>
    
    <content type="html"><![CDATA[<p>老规矩，先上题目</p><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历数组，依次比较相邻的元素(i和i+1),如果两者不相同则向后遍历，i++;相同则后面的所有元素前移一位；每遇到重复的元素，数组长度缩减1</li><li>双指针解法：定义两个指针分别指向目标位和待移动元素位，可定义初始目标位为0，待移动元素位为1，比较两个指针对应的数据，相等则目标位不变，待移动位加1；不相等则目标位加1，待移动元素复制到目标位，待移动位加1<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="comment">//依次比较相邻的元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//不同则往后遍历</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果相同，则后面所有元素往前移动一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">1</span> ; j++) &#123;</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次遇到重复元素，数组长度缩减1</span></span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：通过</li></ul><p>执行用时：435 ms, 在所有 Java 提交中击败了5.03%的用户</p><p>内存消耗：39.3 MB, 在所有 Java 提交中击败了99.50%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n2)<br>空间复杂度:O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个指针</span></span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>; <span class="comment">//目标位指针</span></span><br><span class="line">    <span class="comment">//i待移动位指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果不相等，则目标位加1，但是如果目标位跟移动位相等了，则跳过赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (nums[target] != nums[i]) &#123;</span><br><span class="line">            <span class="comment">//target++;</span></span><br><span class="line">            <span class="keyword">if</span> (++target != i) &#123;</span><br><span class="line">                nums[target] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：1 ms, 在所有 Java 提交中击败了83.23%的用户</p><p>内存消耗：39.9 MB, 在所有 Java 提交中击败了88.46%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n)</p><p>空间复杂度:O(1)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本道题主要使用了双指针，那为什么会使用到双指针呢？就是当我们需要两个数据，并且两者是按照一定的规律同步变化时，我们就可以选择双指针，相对于暴力解法，少了移动元素时所需要的时间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老规矩，先上题目&lt;/p&gt;
&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>java集合总结</title>
    <link href="www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-29T01:58:24.000Z</published>
    <updated>2021-07-07T15:07:09.257Z</updated>
    
    <content type="html"><![CDATA[<p>紧密结构:数组<br>跳转结构:链表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;紧密结构:数组&lt;br&gt;跳转结构:链表&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="java基础" scheme="www.rickzhang.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>谈到环，你应该想到啥</title>
    <link href="www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/"/>
    <id>www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/</id>
    <published>2021-06-27T15:42:33.000Z</published>
    <updated>2021-06-27T15:42:33.626Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-27T13:54:16.000Z</published>
    <updated>2021-06-27T14:12:22.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现跨域的标识"><a href="#出现跨域的标识" class="headerlink" title="出现跨域的标识"></a>出现跨域的标识</h2><p>当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</p><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。<br>常见的跨域：<br><img src="http://images.xiaozhang233.top/image.png" alt="images"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置  Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略，设置响应头中的参数来允许跨域域请求:</p><ol><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Origin 标识允许跨域的请求有哪些<br>例如在java开发中常常这样来解决：</li><li>在POM文件中引入依赖和在web.xml中配置跨域filter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入POM文件 --&gt;</span><br><span class="line">&lt;!-- 解决跨域问题所需依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 在web.xml中配置跨域filter --&gt;</span><br><span class="line">&lt;!--配置跨域过滤器--&gt;</span><br><span class="line">  &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">thetransactioncompany</span>.<span class="title">cors</span>.<span class="title">CORSFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">corsFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>直接导入java类来进行解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(CorsConfiguration.ALL)</span><br><span class="line">                .allowedMethods(CorsConfiguration.ALL)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 1小时内不需要再预检（发OPTIONS请求）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;出现跨域的标识&quot;&gt;&lt;a href=&quot;#出现跨域的标识&quot; class=&quot;headerlink&quot; title=&quot;出现跨域的标识&quot;&gt;&lt;/a&gt;出现跨域的标识&lt;/h2&gt;&lt;p&gt;当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Cont</summary>
      
    
    
    
    
    <category term="前后端交互" scheme="www.rickzhang.cn/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-27-141-环形链表</title>
    <link href="www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-27T13:42:07.000Z</published>
    <updated>2021-06-27T15:41:38.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><strong>示例</strong><br><img src="http://images.xiaozhang233.top/03.jpg" alt="images"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>思路1:遇到环形可以联想到从头遍历到尾，总会有那么几个点会重复遇到，那证明它就含有环了(暴力解法)。<br>思路2：可以转化为追及问题，可以利用快慢链表来实现</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义数组记录已访问的节点</span></span><br><span class="line">    ListNode[] array = <span class="keyword">new</span> ListNode[<span class="number">10000</span>];</span><br><span class="line">    <span class="comment">//2.遍历链表的每个节点</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++&gt;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == head) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                array[i] = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若next指针为null，则说明方法结束，返回false;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：<br>127 ms<br>, 在所有 Java 提交中击败了<br>5.24%<br>的用户</p><p>内存消耗：<br>38.6 MB<br>, 在所有 Java 提交中击败了<br>99.47%<br>的用户<br><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.先判断head是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.定义快慢指针</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="comment">//3.遍历链表：并且设定两个链表的步长</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//4.当且仅当快慢指针重合：有环，操作结束</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.如果不相等，则继续前进</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：<br>0 ms<br>, 在所有 Java 提交中击败了<br>100.00%<br>的用户</p><p>内存消耗：<br>39.7 MB<br>, 在所有 Java 提交中击败了<br>27.29%<br>的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;br&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 </summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-26-02-两数相加</title>
    <link href="www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-06-26T02:49:53.000Z</published>
    <updated>2021-06-26T05:26:26.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因： <span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历两个链表使用数学思维分别转成证书，再进行求和，最后将所求和转为链表(不可取)</li><li>升级版：利用数学思维遍历两个链表，将对应的节点数值进行相加，将结果插入新链表尾部，若数值大于10，则进位，将进位加到下一个节点。<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p = l1, q = l2; <span class="comment">//原链表的两个遍历指针</span></span><br><span class="line">        ListNode resultHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//结果链表的头结点head</span></span><br><span class="line">        ListNode curr = resultHead; <span class="comment">//结果链表的遍历指针，代表当前操作的节点</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点值，如果链表较短，已无节点，取0</span></span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y; <span class="comment">//对应位置节点数值相加</span></span><br><span class="line">            carry = sum / <span class="number">10</span>; <span class="comment">//求进位值，即对10求整</span></span><br><span class="line">            <span class="keyword">int</span> num = sum % <span class="number">10</span>;<span class="comment">//存放到新链表的数值</span></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(num);<span class="comment">//创建新节点存储值</span></span><br><span class="line">            curr = curr.next; <span class="comment">//结果链表向后移动</span></span><br><span class="line">            <span class="comment">//遍历原链表</span></span><br><span class="line">            p = p == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line">            q = q == <span class="keyword">null</span> ? q : q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4.复杂度分析"></a>4.复杂度分析</h2></li><li>时间复杂度：O(max(m,n))</li><li>空间复杂度：O(max(m,n))</li></ul><p><img src="http://qval5nqsx.hn-bkt.clouddn.com/02.jpg" alt="images"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021.06.25|933.最近的请求次数</title>
    <link href="www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/"/>
    <id>www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</id>
    <published>2021-06-25T01:23:24.000Z</published>
    <updated>2021-06-26T02:55:41.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时<br>间（毫秒），返回从 3000 毫秒前（时间范围：[t - 3000, t] ）到现在的 ping 数<br>• 保证每次对 ping 的调用都使用比之前更大的 t 值，1 &lt;= t &lt;= 10^9<br>• 每个测试用例会使用严格递增的 t 值来调用ping，最多调用 10000 次 ping<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inputs = [[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>该题目可以这样理解，最终是要求请求的次数，每次一个请求过来，如果符合([t-3000],t),则记录次数，不符合则不记录，则可以用队列来实现</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q; <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.add(t); <span class="comment">//将请求添加到队列</span></span><br><span class="line">        <span class="comment">//对请求进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (q.peek() &lt; t - <span class="number">3000</span>&gt;) &#123;</span><br><span class="line">            q.poll(); <span class="comment">//不符合则出列</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size(); <span class="comment">//返回总的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析："><a href="#4-复杂度分析：" class="headerlink" title="4. 复杂度分析："></a>4. 复杂度分析：</h2><ul><li>时间复杂度：O(1) //每次添加删除都是O(1)</li><li>空间复杂度: O(1) //最多保留3001个</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时&lt;br</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>小型项目部署篇</title>
    <link href="www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/</id>
    <published>2021-06-24T14:56:19.000Z</published>
    <updated>2021-06-25T01:49:46.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字</strong> 域名 服务器 nginx 代理</p><h4 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h4><ul><li>推荐网站：华为云、阿里云（本人选择）<h4 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a>服务器购买</h4></li><li>推荐网站：华为云、阿里云（本人选择）<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line">service nginx start &#x2F;&#x2F;启动nginx</span><br><span class="line">systemctl enable nginx &#x2F;&#x2F;开启自启</span><br></pre></td></tr></table></figure>安装完nginx后，它的配置文件在/etc/nginx中，打开/etc/nginx/nginx.conf,将user nginx改为user root，保存，不然后续部署项目可能会遇到问题。<h4 id="前端项目打包"><a href="#前端项目打包" class="headerlink" title="前端项目打包"></a>前端项目打包</h4></li><li>打包上传到服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署前端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1000</span>;  <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki.xiaozhang233.top; <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">alias</span> /root/wiki/web/; <span class="comment">#项目路径</span></span><br><span class="line">    <span class="attribute">index</span> index.html; <span class="comment">#首页访问 </span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure><h4 id="JAVA后端项目打包"><a href="#JAVA后端项目打包" class="headerlink" title="JAVA后端项目打包"></a>JAVA后端项目打包</h4></li><li>后端项目打包完成后上传至服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署后端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1001</span>; <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki_server.xiaozhang233.top;  <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8880;<span class="comment">#反向代理，端口号为后端项目运行的端口号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure></li><li>启动JAVA后端项目<br>选择自己想要的目录，创建deploy.sh文件,文件内容为：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "publish----------"</span><br><span class="line"></span><br><span class="line">process_id=`ps -ef | grep edu-zhang.jar | grep -v grep |awk '&#123;print $2&#125;'`</span><br><span class="line">if [ $process_id ] ; then</span><br><span class="line">sudo kill -9 $process_id</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">nohup java -jar -Dspring.profiles.active=prod ~/edu-zhang/edu-zhang.jar &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "end publish"</span><br></pre></td></tr></table></figure></li><li><em>~/edu-zhang/edu-zhang.jar*</em>为自己项目的地址</li><li>执行：sh deploy.sh 启动项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt; 域名 服务器 nginx 代理&lt;/p&gt;
&lt;h4 id=&quot;域名购买&quot;&gt;&lt;a href=&quot;#域名购买&quot; class=&quot;headerlink&quot; title=&quot;域名购买&quot;&gt;&lt;/a&gt;域名购买&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;推荐网站：华为云、阿里云</summary>
      
    
    
    
    
    <category term="项目部署" scheme="www.rickzhang.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-24-07-整数反转</title>
    <link href="www.rickzhang.cn/2021/06/24/2021-06-24-07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>www.rickzhang.cn/2021/06/24/2021-06-24-07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2021-06-24T05:29:07.000Z</published>
    <updated>2021-06-27T13:30:39.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出一个 32 位的有符号整数，将这个整数每位上的数字进行反转</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：-<span class="number">123</span></span><br><span class="line">输出：-<span class="number">321</span>  <span class="comment">//符号不变</span></span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span> <span class="comment">//首位非0;数值溢出返回0;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，将这个整数每位上的数字进行反转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>mysql安装篇</title>
    <link href="www.rickzhang.cn/2021/06/23/mysql%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/06/23/mysql%E5%AE%89%E8%A3%85%E7%AF%87/</id>
    <published>2021-06-23T09:00:06.000Z</published>
    <updated>2021-06-23T09:08:31.300Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载mysql</li><li>进行安装</li><li>配置</li><li>食用</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;下载mysql&lt;/li&gt;
&lt;li&gt;进行安装&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;li&gt;食用&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
    <category term="软件安装" scheme="www.rickzhang.cn/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>常见API(上)</title>
    <link href="www.rickzhang.cn/2020/05/31/%E5%B8%B8%E8%A7%81API-%E4%B8%8A/"/>
    <id>www.rickzhang.cn/2020/05/31/%E5%B8%B8%E8%A7%81API-%E4%B8%8A/</id>
    <published>2020-05-31T12:10:38.000Z</published>
    <updated>2020-05-31T12:18:55.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><a id="more"></a><h3 id="1-1API概述【理解】"><a href="#1-1API概述【理解】" class="headerlink" title="1.1API概述【理解】"></a>1.1API概述【理解】</h3><ul><li><p>什么是API</p><p>​    API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p>​    指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h3 id="1-2如何使用API帮助文档【应用】"><a href="#1-2如何使用API帮助文档【应用】" class="headerlink" title="1.2如何使用API帮助文档【应用】"></a>1.2如何使用API帮助文档【应用】</h3><ul><li>打开帮助文档</li></ul><p><img src="img%5C01.png" alt=""></p><ul><li>找到索引选项卡中的输入框</li></ul><p><img src="img%5C02.png" alt=""></p><ul><li>在输入框中输入Random</li></ul><p><img src="img%5C03.png" alt=""></p><ul><li>看类在哪个包下</li></ul><p><img src="img%5C04.png" alt=""></p><ul><li>看类的描述</li></ul><p><img src="img%5C05.png" alt=""></p><ul><li>看构造方法</li></ul><p><img src="img%5C06.png" alt=""></p><ul><li>看成员方法</li></ul><p><img src="img%5C07.png" alt=""></p><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述【理解】"><a href="#2-1String类概述【理解】" class="headerlink" title="2.1String类概述【理解】"></a>2.1String类概述【理解】</h3><p>​    String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点【理解】"><a href="#2-2String类的特点【理解】" class="headerlink" title="2.2String类的特点【理解】"></a>2.2String类的特点【理解】</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法【记忆】"><a href="#2-3String类的构造方法【记忆】" class="headerlink" title="2.3String类的构造方法【记忆】"></a>2.3String类的构造方法【记忆】</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public   String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s =   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public String()：创建一个空白字符串对象，不含有任何内容</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String();</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(chs);</span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(bys);</span><br><span class="line">        System.out.println(<span class="string">"s3:"</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = “abc”;直接赋值的方式创建字符串对象，内容就是abc</span></span><br><span class="line">        String s4 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(<span class="string">"s4:"</span> + s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4创建字符串对象两种方式的区别【理解】"><a href="#2-4创建字符串对象两种方式的区别【理解】" class="headerlink" title="2.4创建字符串对象两种方式的区别【理解】"></a>2.4创建字符串对象两种方式的区别【理解】</h3><ul><li><p>通过构造方法创建</p><p>​    通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p>​    以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ul><h3 id="2-5字符串的比较【理解】"><a href="#2-5字符串的比较【理解】" class="headerlink" title="2.5字符串的比较【理解】"></a>2.5字符串的比较【理解】</h3><h4 id="2-5-1-号的作用"><a href="#2-5-1-号的作用" class="headerlink" title="2.5.1==号的作用"></a>2.5.1==号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h4 id="2-5-2equals方法的作用"><a href="#2-5-2equals方法的作用" class="headerlink" title="2.5.2equals方法的作用"></a>2.5.2equals方法的作用</h4><ul><li><p>方法介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String s)</span>     比较两个字符串内容是否相同、区分大小写</span></span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法的方式得到对象</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(chs);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接赋值的方式得到对象</span></span><br><span class="line">        String s3 = <span class="string">"abc"</span>;</span><br><span class="line">        String s4 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串对象地址是否相同</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6用户登录案例【应用】"><a href="#2-6用户登录案例【应用】" class="headerlink" title="2.6用户登录案例【应用】"></a>2.6用户登录案例【应用】</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​    已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line"><span class="comment">        2:键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line"><span class="comment">        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line">        String username = <span class="string">"itheima"</span>;</span><br><span class="line">        String password = <span class="string">"czbk"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">            String name = sc.nextLine();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">            String pwd = sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(username) &amp;&amp; pwd.equals(password)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>-i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"你的账户被锁定，请与管理员联系"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//2,1,0</span></span><br><span class="line">                    <span class="comment">//i,0,1,2</span></span><br><span class="line">                    System.out.println(<span class="string">"登录失败，你还有"</span> + (<span class="number">2</span> - i) + <span class="string">"次机会"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7遍历字符串案例【应用】"><a href="#2-7遍历字符串案例【应用】" class="headerlink" title="2.7遍历字符串案例【应用】"></a>2.7遍历字符串案例【应用】</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​    键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:遍历字符串，首先要能够获取到字符串中的每一个字符</span></span><br><span class="line"><span class="comment">            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">        3:遍历字符串，其次要能够获取到字符串的长度</span></span><br><span class="line"><span class="comment">            public int length()：返回此字符串的长度</span></span><br><span class="line"><span class="comment">            数组的长度：数组名.length</span></span><br><span class="line"><span class="comment">            字符串的长度：字符串对象.length()</span></span><br><span class="line"><span class="comment">        4:遍历字符串的通用格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            System.out.println(line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8统计字符次数案例【应用】"><a href="#2-8统计字符次数案例【应用】" class="headerlink" title="2.8统计字符次数案例【应用】"></a>2.8统计字符次数案例【应用】</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​    键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line"><span class="comment">        3:遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="comment">        4:判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line"><span class="comment">            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可</span></span><br><span class="line"><span class="comment">            大写字母：ch&gt;='A' &amp;&amp; ch&lt;='Z'</span></span><br><span class="line"><span class="comment">            小写字母： ch&gt;='a' &amp;&amp; ch&lt;='z'</span></span><br><span class="line"><span class="comment">            数字： ch&gt;='0' &amp;&amp; ch&lt;='9'</span></span><br><span class="line"><span class="comment">        5:输出三种类型的字符个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line">        <span class="keyword">int</span> bigCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> smallCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = line.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'A'</span> &amp;&amp; ch&lt;=<span class="string">'Z'</span>) &#123;</span><br><span class="line">                bigCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>) &#123;</span><br><span class="line">                smallCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                numberCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出三种类型的字符个数</span></span><br><span class="line">        System.out.println(<span class="string">"大写字母："</span> + bigCount + <span class="string">"个"</span>);</span><br><span class="line">        System.out.println(<span class="string">"小写字母："</span> + smallCount + <span class="string">"个"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数字："</span> + numberCount + <span class="string">"个"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9字符串拼接案例【应用】"><a href="#2-9字符串拼接案例【应用】" class="headerlink" title="2.9字符串拼接案例【应用】"></a>2.9字符串拼接案例【应用】</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​    定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​    并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">                s += <span class="string">", "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10字符串反转案例【应用】"><a href="#2-10字符串反转案例【应用】" class="headerlink" title="2.10字符串反转案例【应用】"></a>2.10字符串反转案例【应用】</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​    定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​    例如，键盘录入 abc，输出结果 cba</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = reverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line">        String ss = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ss += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11帮助文档查看String常用方法【记忆】"><a href="#2-11帮助文档查看String常用方法【记忆】" class="headerlink" title="2.11帮助文档查看String常用方法【记忆】"></a>2.11帮助文档查看String常用方法【记忆】</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   equals(Object anObject)</td><td>比较字符串的内容，严格区分大小写(用户名和密码)</td></tr><tr><td>public char charAt(int   index)</td><td>返回指定索引处的 char 值</td></tr><tr><td>public int   length()</td><td>返回此字符串的长度</td></tr></tbody></table><h2 id="3-StringBuilder类"><a href="#3-StringBuilder类" class="headerlink" title="3.StringBuilder类"></a>3.StringBuilder类</h2><h3 id="3-1StringBuilder类概述【理解】"><a href="#3-1StringBuilder类概述【理解】" class="headerlink" title="3.1StringBuilder类概述【理解】"></a>3.1StringBuilder类概述【理解】</h3><p>​    StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的</p><h3 id="3-2StringBuilder类和String类的区别【理解】"><a href="#3-2StringBuilder类和String类的区别【理解】" class="headerlink" title="3.2StringBuilder类和String类的区别【理解】"></a>3.2StringBuilder类和String类的区别【理解】</h3><ul><li>String类：内容是不可变的</li><li>StringBuilder类：内容是可变的</li></ul><h3 id="3-3StringBuilder类的构造方法【记忆】"><a href="#3-3StringBuilder类的构造方法【记忆】" class="headerlink" title="3.3StringBuilder类的构造方法【记忆】"></a>3.3StringBuilder类的构造方法【记忆】</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr><td>public StringBuilder(String   str)</td><td>根据字符串的内容，来创建可变字符串对象</td></tr></tbody></table></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"sb.length():"</span> + sb.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"sb2:"</span> + sb2);</span><br><span class="line">        System.out.println(<span class="string">"sb2.length():"</span> + sb2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4StringBuilder类添加和反转方法【记忆】"><a href="#3-4StringBuilder类添加和反转方法【记忆】" class="headerlink" title="3.4StringBuilder类添加和反转方法【记忆】"></a>3.4StringBuilder类添加和反转方法【记忆】</h3><ul><li><p>添加和反转方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder   append(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr><td>public StringBuilder   reverse()</td><td>返回相反的字符序列</td></tr></tbody></table></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder append(任意类型)：添加数据，并返回对象本身</span></span><br><span class="line"><span class="comment">//        StringBuilder sb2 = sb.append("hello");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("sb:" + sb);</span></span><br><span class="line"><span class="comment">//        System.out.println("sb2:" + sb2);</span></span><br><span class="line"><span class="comment">//        System.out.println(sb == sb2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sb.append("hello");</span></span><br><span class="line"><span class="comment">//        sb.append("world");</span></span><br><span class="line"><span class="comment">//        sb.append("java");</span></span><br><span class="line"><span class="comment">//        sb.append(100);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        sb.append(<span class="string">"hello"</span>).append(<span class="string">"world"</span>).append(<span class="string">"java"</span>).append(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder reverse()：返回相反的字符序列</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(<span class="string">"sb:"</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5StringBuilder和String相互转换【应用】"><a href="#3-5StringBuilder和String相互转换【应用】" class="headerlink" title="3.5StringBuilder和String相互转换【应用】"></a>3.5StringBuilder和String相互转换【应用】</h3><ul><li><p>StringBuilder转换为String</p><p>​        public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String</p></li><li><p>String转换为StringBuilder</p><p>​        public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //StringBuilder 转换为 String</span></span><br><span class="line"><span class="comment">        StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">        sb.append("hello");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //String s = sb; //这个是错误的做法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String</span></span><br><span class="line"><span class="comment">        String s = sb.toString();</span></span><br><span class="line"><span class="comment">        System.out.println(s);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 转换为 StringBuilder</span></span><br><span class="line">        String s = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder sb = s; //这个是错误的做法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6字符串拼接升级版案例【应用】"><a href="#3-6字符串拼接升级版案例【应用】" class="headerlink" title="3.6字符串拼接升级版案例【应用】"></a>3.6字符串拼接升级版案例【应用】</h3><h4 id="3-6-1案例需求"><a href="#3-6-1案例需求" class="headerlink" title="3.6.1案例需求"></a>3.6.1案例需求</h4><p>​    定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​    并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="3-6-2代码实现"><a href="#3-6-2代码实现" class="headerlink" title="3.6.2代码实现"></a>3.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        String s = sb.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7字符串反转升级版案例【应用】"><a href="#3-7字符串反转升级版案例【应用】" class="headerlink" title="3.7字符串反转升级版案例【应用】"></a>3.7字符串反转升级版案例【应用】</h3><h4 id="3-7-1案例需求"><a href="#3-7-1案例需求" class="headerlink" title="3.7.1案例需求"></a>3.7.1案例需求</h4><p>​    定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​    例如，键盘录入abc，输出结果 cba</p><h4 id="3-7-2代码实现"><a href="#3-7-2代码实现" class="headerlink" title="3.7.2代码实现"></a>3.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中用StringBuilder实现字符串的反转，并把结果转成String返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        String s = myReverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"s:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法中用StringBuilder实现字符串的反转，并把结果转成String返回</span></span><br><span class="line">        <span class="comment">//String --- StringBuilder --- reverse() --- String</span></span><br><span class="line"><span class="comment">//        StringBuilder sb = new StringBuilder(s);</span></span><br><span class="line"><span class="comment">//        sb.reverse();</span></span><br><span class="line"><span class="comment">//        String ss = sb.toString();</span></span><br><span class="line"><span class="comment">//        return ss;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8帮助文档查看StringBuilder常用方法【记忆】"><a href="#3-8帮助文档查看StringBuilder常用方法【记忆】" class="headerlink" title="3.8帮助文档查看StringBuilder常用方法【记忆】"></a>3.8帮助文档查看StringBuilder常用方法【记忆】</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   StringBuilder append (任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr><td>public   StringBuilder reverse()</td><td>返回相反的字符序列</td></tr><tr><td>public   int   length()</td><td>返回长度，实际存储值</td></tr><tr><td>public   String toString()</td><td>通过toString()就可以实现把StringBuilder转换为String</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-API&quot;&gt;&lt;a href=&quot;#1-API&quot; class=&quot;headerlink&quot; title=&quot;1.API&quot;&gt;&lt;/a&gt;1.API&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="www.rickzhang.cn/2020/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>www.rickzhang.cn/2020/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-05T12:59:34.000Z</published>
    <updated>2020-05-05T13:10:27.992Z</updated>
    
    <content type="html"><![CDATA[<p>对于二叉树，你了解多少？</p><a id="more"></a><h2 id="对于二叉树，你应该了解这些名词"><a href="#对于二叉树，你应该了解这些名词" class="headerlink" title="对于二叉树，你应该了解这些名词"></a>对于二叉树，你应该了解这些名词</h2><ul><li>节点、根节点、父节点、子节点、兄弟节点</li><li>一棵树可以没有任何节点，成为空数</li><li>一棵树可以只有1个节点，也就是只有根节点</li><li>子树、左子树、右子树</li><li>节点的度：子树的个数</li><li>树的度：所有节点度中的最大值</li><li>叶子节点：度为0的节点</li><li>非叶子节点：度不为0的节点</li><li>层数：根节点在第 1 层，根节点的子节点在第 2 层</li><li>节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数</li><li>树的深度：所有节点深度中的最大值</li><li>节点的高度：从当前节点到最远叶子节点的路径上的节点总数</li><li>树的高度：所以节点高度中的最大值</li><li>树的深度 == 树的高度<h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2></li><li>有序树：树中任意节点的子节点之间有顺序关系</li><li>无序树：数中任意节点的子节点之间没有顺序关系，也成“自由树”</li><li>森林：由m（m &gt;= 0）棵互不相交的树组成的集合<h2 id="接下来就是重点了–二叉树"><a href="#接下来就是重点了–二叉树" class="headerlink" title="接下来就是重点了–二叉树"></a>接下来就是重点了–二叉树</h2><ol><li>特点：</li></ol></li><li>每个节点的度最大为2（最多拥有2棵子树）</li><li>左子树和右子树是有顺序的</li><li>即使某节点只有一棵子树，也要区分左右子树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉树是有序树还是无序树？</span><br><span class="line">有序树</span><br></pre></td></tr></table></figure><ol start="2"><li>性质：</li></ol></li><li>非空二叉树的第i层，最多有2的（i-1）次幂个节点（i &gt;= 1）</li><li>在高度为h的二叉树上最多有（2的（h）次幂）-1个节点（h &gt;= 1）</li><li>对于任何一棵非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有：n0 = n2 + 1</li><li>假设度为1的节点个数为n1，那么二叉树的节点总数n = n0 + n1 + n2 - 1,因此n0 = n2 + 1</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于二叉树，你了解多少？&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structures" scheme="www.rickzhang.cn/tags/data-structures/"/>
    
  </entry>
  
  <entry>
    <title>java之旅01</title>
    <link href="www.rickzhang.cn/2020/02/26/java%E4%B9%8B%E6%97%8501/"/>
    <id>www.rickzhang.cn/2020/02/26/java%E4%B9%8B%E6%97%8501/</id>
    <published>2020-02-26T13:36:39.000Z</published>
    <updated>2020-02-26T13:42:42.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java之旅01"><a href="#java之旅01" class="headerlink" title="java之旅01"></a>java之旅01</h1><a id="more"></a><p>字符串常量：要用双引号引起来<br>空常量不能直接打印出来<br>变量：内容可以变的量，定义格式跟C语言一样<br>对于float和long类型来说，字母后缀F和L不要丢掉。<br>没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。<br>/*<br>当数据类型不一样时，将会发生数据类型转换。</p><p>自动类型转换（隐式）<br>    1. 特点：代码不需要进行特殊处理，自动完成。<br>    2. 规则：数据范围从小到大。</p><p>强制类型转换（显式）<br><em>/<br>/</em><br>强制类型转换<br>    1. 特点：代码需要进行特殊的格式处理，不能自动完成。<br>    2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</p><p>注意事项：<br>    1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。<br>    2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.<br>    3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。<br>    4. boolean类型不能发生数据类型转换<br><em>/<br>eg：double–&gt;int 小数点直接舍弃，而非四舍五入<br>一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字<br>一般进行加减法时，无论是short，byte，都会自动转化为int类型再进行加减<br>/</em><br>数字和字符的对照关系表（编码表）：</p><p>ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。<br>Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</p><p>48 - ‘0’<br>65 - ‘A’<br>97 - ‘a’<br><em>/<br>运算符：+—</em>/%  除法用的是整数之间的，只看商，不看余数，%—》只有对于整数的出发来说，取模运算才有余数的意义<br>变量之间进行相加减时，会首先转化为定变量的数据类型在再进行计算<br>/*<br>四则运算当中的加号“+”有常见的三种用法：</p><ol><li>对于数值来说，那就是加法。</li><li>对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。<br>char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode</li><li>对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。<br>任何数据类型和字符串进行连接的时候，结果都会变成字符串</li></ol><p>*/<br>++ 与 –的用法<br>一般分为单独使用和混合使用，单独使用没什么特别注意的，该+的+，该-的-<br>混合使用则值得注意：1)如果是++num，则会先加再进行使用   —-先加后用<br>                  2)如果是num++，则先使用变量本来的值，再执行+   —–先用后加<br>赋值运算符：基本赋值和复合赋值   复合赋值运算符其中隐含了一个强制类型转换。<br>byte num = 30;<br>        // num = num + 5;<br>        // num = byte + int<br>        // num = int + int<br>        // num = int<br>        // num = (byte) int<br>        num += 5;<br>        System.out.println(num); // 35<br>逻辑运算符：与&amp;&amp;  或|| 非！<br>一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反!、自增++、自减–<br>二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=<br>三元运算符：需要三个数据才可以进行操作的运算符。</p><p>格式：<br>数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;</p><p>流程：<br>首先判断条件是否成立：<br>    如果成立为true，那么将表达式A的值赋值给左侧的变量；<br>    如果不成立为false，那么将表达式B的值赋值给左侧的变量；<br>二者选其一。</p><p>注意事项：</p><ol><li><p>必须同时保证表达式A和表达式B都符合左侧数据类型的要求。</p></li><li><p>三元运算符的结果必须被使用。<br>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，<br>那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。</p></li><li><p>如果没有超过左侧的范围，编译器补上强转。</p></li><li><p>如果右侧超过了左侧范围，那么直接编译器报错。</p></li></ol><p>/*<br>在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，<br>那么编译器javac将会直接将若干个常量表达式计算得到结果。<br>short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算<br>编译之后，得到的.class字节码文件当中相当于【直接就是】：<br>short result = 13;<br>右侧的常量结果数值，没有超过左侧范围，所以正确。</p><p>这称为“编译器的常量优化”。</p><p>但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。<br>*/<br>====================================================================<br>方法的命名规则和变量名一样，使用小驼峰，类名使用大驼峰<br>格式：  public static void 方法名称(){<br>    方法体<br>}<br>方法的定义不能产生嵌套包含关系。要使用方法需进行调用(跟C语言的函数调用一样的道理)–调用格式：方法名称（）</p><p>====================================================================<br>顺序结构<br>if   if-else switch<br>switch后面小括号当中只能是下列数据类型：<br>基本数据类型：byte/short/char/int<br>引用数据类型：String字符串、enum枚举<br>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。<br>“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”</p><p>循环结构的基本组成部分：初始化语句、条件判断、循环体、步进语句<br>for<br>while<br>do-while<br>三种循环的区别。</p><ol><li><p>如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。</p></li><li><p>for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环<br>break关键字的用法有常见的两种：</p></li><li><p>可以用在switch语句当中，一旦执行，整个switch语句立刻结束。</p></li><li><p>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</p></li></ol><p>关于循环的选择，有一个小建议：<br>凡是次数确定的场景多用for循环；否则多用while循环。<br>continue：另一种循环控制语句是continue关键字。<br>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。</p><p>常见死循环：while(true){<br>    循环体<br>}</p><h1 id="方法"><a href="#方法" class="headerlink" title="=====方法===="></a>=====方法====</h1><p>方法不能嵌套，必须调用才能使用到它<br>方法格式：<br>修饰符 返回值类型 方法名称（参数类型 参数名称） {</p><pre><code>方法体return返回值；</code></pre><p>}<br>修饰符：现阶段的固定写法，public static<br>返回值类型：也就是方法最终产生的数据结果是什么类型<br>方法名称：方法的名字，规则和变量一样，小驼峰<br>参数类型：进入方法的数据是什么类型<br>参数名称：进入方法的数据对应的变量名称<br>PS：参数如果有多个，使用逗号进行分隔<br>方法体：方法需要做的事情，若干行代码<br>return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处<br>返回值：也就是方法执行后最终产生的数据结果</p><p>注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。<br>方法的三种调用格式：<br>1单独调用2打印调用3赋值调用<br>当返回类型为void时，只能单独调用，不能进行打印调用或者赋值调用<br>====如何判断方法是否需要参数0–<br>有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。<br>例如两个数字相加，必须知道两个数字是各自多少，才能相加。</p><p>无参数：小括号当中留空。一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。<br>例如定义一个方法，打印固定10次HelloWorld。</p><p>定义一个方法常用思路：<br>返回值类型、方法名称、参数列表</p><p>=======使用方法注意事项=====</p><ol><li>方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。</li><li>方法定义的前后顺序无所谓。</li><li>方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。</li><li>如果方法有返回值，那么必须写上“return 返回值;”，不能没有。</li><li>return后面的返回值数据，必须和方法的返回值类型，对应起来。</li><li>对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。</li><li>对于void方法当中最后一行的return可以省略不写。</li><li>一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。</li></ol><p>======方法重载======<br>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称，太麻烦。<br>方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。<br>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。<br>方法重载与下列因素相关：</p><ol><li>参数个数不同</li><li>参数类型不同</li><li>参数的多类型顺序不同</li></ol><p>方法重载与下列因素无关：</p><ol><li>与参数的名称无关</li><li>与方法的返回值类型无关</li></ol><p>在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。</p><h1 id="进入数组"><a href="#进入数组" class="headerlink" title="=====进入数组===="></a>=====进入数组====</h1><p>int[] array = new ing[5];<br>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol><li>数组是一种引用数据类型</li><li>数组当中的多个数据，类型必须统一</li><li>数组的长度在程序运行期间不可改变</li></ol><p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p><p>两种常见的初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><p>动态初始化数组的格式：<br>数据类型[] 数组名称 = new 数据类型[数组长度];</p><p>解析含义：<br>左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型<br>左侧的中括号：代表我是一个数组<br>左侧数组名称：给数组取一个名字<br>右侧的new：代表创建数组的动作<br>右侧数据类型：必须和左边的数据类型保持一致<br>右侧中括号的长度  ：也就是数组当中，到底可以保存多少个数据，是一个int数字<br>静态初始化基本格式：<br>数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … };<br>静态可省略格式：<br>数据类型【】 数组名称 = {元素1，元素2，。。。。。}<br>动态与静态使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。<br>直接打印数组名称，得到的是数组对应的：内存地址哈希值。<br>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：<br>如果是整数类型，那么默认为0；<br>如果是浮点类型，那么默认为0.0；<br>如果是字符类型，那么默认为’\u0000’；<br>如果是布尔类型，那么默认为false；<br>如果是引用类型，那么默认为null。<br>静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。<br>数组必须进行new初始化才能使用其中的元素。<br>如果只是赋值了一个null，没有进行new创建，<br>那么将会发生：<br>空指针异常 NullPointerException<br>数组可以作为方法的参数。<br>当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。<br>一个方法可以有0、1、多个参数；但是只能有0或者1个返回值，不能有多个返回值。<br>如果希望一个方法当中产生了多个结果数据进行返回，怎么办？<br>解决方案：使用一个数组作为返回值类型即可。</p><h1 id="进入类"><a href="#进入类" class="headerlink" title="====进入类====="></a>====进入类=====</h1><p>类由成员变量(属性）和成员方法（行为）组成<br>成员变量是直接定义在类当中的，在方法外边。<br>成员方法不要写static关键字<br>面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。<br>面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。</p><p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。</p><ol><li><p>导包：也就是指出需要使用的类，在什么位置。<br>import 包名称.类名称;<br>import cn.itcast.day06.demo01.Student;<br>对于和当前类属于同一个包的情况，可以省略导包语句不写。</p></li><li><p>创建，格式：<br>类名称 对象名 = new 类名称();<br>Student stu = new Student();</p></li><li><p>使用，分为两种情况：<br>使用成员变量：对象名.成员变量名<br>使用成员方法：对象名.成员方法名(参数)<br>（也就是，想用谁，就用对象名点儿谁。）</p></li></ol><p>注意事项：<br>如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。<br>例如：<br>成员变量（属性）：<br>    String brand; // 品牌<br>    double price; // 价格<br>    String color; // 颜色<br>成员方法（行为）：<br>    public void call(String who) {} // 打电话<br>    public void sendMessage() {} // 群发短信</p><p>private对成员变量进行修饰<br>一旦使用了private进行修饰，那么本类当中仍然可以随意访问。<br>但是！超出了本类范围之外就不能再直接访问了。</p><p>间接访问private成员变量，就是定义一对儿Getter/Setter方法</p><p>必须叫setXxx或者是getXxx命名规则。<br>对于Getter来说，不能有参数，返回值类型和成员变量对应；<br>对于Setter来说，不能有返回值，参数类型和成员变量对应。<br>例如：<br>public class Person {</p><pre><code>String name; // 姓名private int age; // 年龄public void show() {    System.out.println(&quot;我叫：&quot; + name + &quot;，年龄：&quot; + age);}// 这个成员方法，专门用于向age设置数据public void setAge(int num) {    if (num &lt; 100 &amp;&amp; num &gt;= 9) { // 如果是合理情况        age = num;    } else {        System.out.println(&quot;数据不合理！&quot;);    }}// 这个成员方法，专门私语获取age的数据public int getAge() {    return age;}</code></pre><p>}<br>对于private修饰的变量，必须通过.setage/.getage来赋值或者访问</p><p>局部变量与成员变量的区别;</p><ol><li><p>定义的位置不一样【重点】<br>局部变量：在方法的内部<br>成员变量：在方法的外部，直接写在类当中</p></li><li><p>作用范围不一样【重点】<br>局部变量：只有方法当中才可以使用，出了方法就不能再用<br>成员变量：整个类全都可以通用。</p></li><li><p>默认值不一样【重点】<br>局部变量：没有默认值，如果要想使用，必须手动进行赋值<br>成员变量：如果没有赋值，会有默认值，规则和数组一样</p></li><li><p>内存的位置不一样（了解）<br>局部变量：位于栈内存<br>成员变量：位于堆内存</p></li><li><p>生命周期不一样（了解）<br>局部变量：随着方法进栈而诞生，随着方法出栈而消失<br>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p></li></ol><p>面向对象三大特征：封装、继承、多态。<br>方法就是一种封装、关键字private也是一种封装<br>封装就是将一些细节信息隐藏起来，对于外界不可见。</p><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>如果需要访问本类当中的成员变量，需要使用格式：<br>this.成员变量名</p><p>“通过谁调用的方法，谁就是this。”</p><h1 id="构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。"><a href="#构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。" class="headerlink" title="构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。"></a>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。</h1><p>格式：<br>public 类名称(参数类型 参数名称) {</p><pre><code>方法体</code></pre><p>}</p><p>注意事项：</p><ol><li><p>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</p></li><li><p>构造方法不要写返回值类型，连void都不写</p></li><li><p>构造方法不能return一个具体的返回值</p></li><li><p>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。<br>public Student() {}</p></li><li><p>一旦编写了至少一个构造方法，那么编译器将不再赠送。</p></li><li><p>构造方法也是可以进行重载的。<br>重载：方法名称相同，参数列表不同。</p><h1 id="一个标准的类通常要拥有下面四个组成部分："><a href="#一个标准的类通常要拥有下面四个组成部分：" class="headerlink" title="一个标准的类通常要拥有下面四个组成部分："></a>一个标准的类通常要拥有下面四个组成部分：</h1><ol><li>所有的成员变量都要使用private关键字修饰</li><li>为每一个成员变量编写一对儿Getter/Setter方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><p>这样标准的类也叫做Java Bean</p></li></ol><p>Scanner类的功能：可以实现键盘输入数据，到程序当中。</p><p>引用类型的一般使用步骤：</p><ol><li><p>导包<br>import 包路径.类名称;<br>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。<br>只有java.lang包下的内容不需要导包，其他的包都需要import语句。</p></li><li><p>创建<br>类名称 对象名 = new 类名称();</p></li><li><p>使用<br>对象名.成员方法名()</p></li></ol><p>获取键盘输入的一个int数字：int num = sc.nextInt();<br>获取键盘输入的一个字符串：String str = sc.next();<br>创建类步骤：<br>导包—创建—使用<br>例如： // 备注：System.in代表从键盘进行输入<br>        Scanner sc = new Scanner(System.in);</p><pre><code>// 3. 获取键盘输入的int数字int num = sc.nextInt();System.out.println(&quot;输入的int数字是：&quot; + num);// 4. 获取键盘输入的字符串String str = sc.next();System.out.println(&quot;输入的字符串是：&quot; + str);</code></pre><p>匿名对象：：：<br>创建对象的标准格式：<br>类名称 对象名 = new 类名称();</p><p>匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。<br>new 类名称();</p><p>注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。<br>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。<br>// 普通使用方式<br>//        Scanner sc = new Scanner(System.in);<br>//        int num = sc.nextInt();</p><pre><code>// 匿名对象的方式</code></pre><p>//        int num = new Scanner(System.in).nextInt();<br>//        System.out.println(“输入的是：” + num);</p><pre><code>// 使用一般写法传入参数</code></pre><p>//        Scanner sc = new Scanner(System.in);<br>//        methodParam(sc);</p><pre><code>// 使用匿名对象来进行传参</code></pre><p>//        methodParam(new Scanner(System.in));</p><p>======几种类的学习======<br>一 —Random<br>导包、创建、使用<br>Random r = new Random()<br>int num = r.nextInt(0,3);//可加参数,数字是从0开始算起，如果想生成范围从大于0开始的，可以加上一个数<br>例如生成一个3~5的数，可表示为：<br>int num = r.nextInt(4)+1;</p><p>二 —-集合<br>数组的长度不可以发生改变。<br>但是ArrayList集合的长度是可以随意变化的。</p><p>对于ArrayList来说，有一个尖括号<E>代表泛型。<br>泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。<br>注意：泛型只能是引用类型，不能是基本类型。</p><p>注意事项：<br>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。<br>如果内容是空，得到的是空的中括号：[]<br>ArrayList<Integer> list = new ArrayList&lt;&gt;();<br>list.add(1);<br>ArrayList当中的常用方法有：</p><p>public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。<br>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。<br>但是对于其他集合（今后学习）来说，add添加动作不一定成功。</p><p>public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</p><p>public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</p><p>public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。<br>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</p><p>基本类型    包装类（引用类型，包装类都位于java.lang包下）<br>byte        Byte<br>short       Short<br>int         Integer     【特殊】<br>long        Long<br>float       Float<br>double      Double<br>char        Character   【特殊】<br>boolean     Boolean</p><p>从JDK 1.5+开始，支持自动装箱、自动拆箱。</p><p>自动装箱：基本类型 –&gt; 包装类型<br>自动拆箱：包装类型 –&gt; 基本类型java.lang.String类代表字符串。<br>API当中说：Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）</p><p>字符串的特点：</p><ol><li>字符串的内容永不可变。【重点】</li><li>正是因为字符串不可改变，所以字符串是可以共享使用的。</li><li>字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。</li></ol><p>创建字符串的常见3+1种方式。<br>三种构造方法：<br>public String()：创建一个空白字符串，不含有任何内容。<br>public String(char[] array)：根据字符数组的内容，来创建对应的字符串。<br>public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。<br>一种直接创建：<br>String str = “Hello”; // 右边直接用双引号</p><p>注意：直接写上双引号，就是字符串对象。</p><p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。</p><p>对于基本类型来说，==是进行数值的比较。<br>对于引用类型来说，==是进行【地址值】的比较。</p><p>public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同<br>的才会给true；否则返回false。</p><p>public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。</p><p>String当中与获取相关的常用方法有：</p><p>public int length()：获取字符串当中含有的字符个数，拿到字符串长度。<br>public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。<br>public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）<br>public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</p><p>public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。<br>public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。<br>备注：[begin,end)，包含左边，不包含右边。</p><p>String当中与转换相关的常用方法有：</p><p>public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。<br>public byte[] getBytes()：获得当前字符串底层的字节数组。<br>public String replace(CharSequence oldString, CharSequence newString)：<br>将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。<br>备注：CharSequence意思就是说可以接受字符串类型。</p><p>分割字符串的方法：<br>public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。</p><p>注意事项：<br>split方法的参数其实是一个“正则表达式”，今后学习。<br>今天要注意：如果按照英文句点“.”进行切分，必须写”\.”（两个反斜杠）</p><p>如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。例如：多个人共享一个教室</p><h2 id="一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。"><a href="#一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。" class="headerlink" title="一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。"></a>一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</h2><p>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。<br>如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</p><p>无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。<br>静态变量：类名称.静态变量<br>静态方法：类名称.静态方法()</p><p>注意事项：</p><ol><li><p>静态不能直接访问非静态。<br>原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。<br>“先人不知道后人，但是后人知道先人。”</p></li><li><p>静态方法当中不能用this。<br>原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</p><p>静态代码块的格式是：</p><p>public class 类名称 {<br>   static {</p><pre><code>// 静态代码块的内容</code></pre><p>   }<br>}</p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的典型用途：<br>用来一次性地对静态成员变量进行赋值。</p><p>​</p></li></ol><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</p><p>public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]）<br>public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。</p><p>备注：</p><ol><li>如果是数值，sort默认按照升序从小到大</li><li>如果是字符串，sort默认按照字母升序</li><li>如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习）</li></ol><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</p><p>public static double abs(double num)：获取绝对值。有多种重载。<br>public static double ceil(double num)：向上取整。<br>public static double floor(double num)：向下取整。<br>public static long round(double num)：四舍五入。</p><p>Math.PI代表近似的圆周率常量（double）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java之旅01&quot;&gt;&lt;a href=&quot;#java之旅01&quot; class=&quot;headerlink&quot; title=&quot;java之旅01&quot;&gt;&lt;/a&gt;java之旅01&lt;/h1&gt;</summary>
    
    
    
    
    <category term="java学习" scheme="www.rickzhang.cn/tags/java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-08-14T01:45:46.924Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>15.三数之和</title>
    <link href="www.rickzhang.cn/2021/08/14/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>www.rickzhang.cn/2021/08/14/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-08-14T01:45:46.000Z</published>
    <updated>2021-08-14T01:45:46.924Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>14.最长公共前缀</title>
    <link href="www.rickzhang.cn/2021/08/10/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>www.rickzhang.cn/2021/08/10/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2021-08-10T07:56:57.000Z</published>
    <updated>2021-08-10T07:56:57.592Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="www.rickzhang.cn/2021/08/10/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>www.rickzhang.cn/2021/08/10/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2021-08-10T07:56:23.000Z</published>
    <updated>2021-08-10T07:56:23.161Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>104.二叉树的最大深度</title>
    <link href="www.rickzhang.cn/2021/08/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>www.rickzhang.cn/2021/08/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2021-08-08T08:30:03.000Z</published>
    <updated>2021-08-10T15:31:15.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例</strong></p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>对于二叉树求深度主要的遍历方式有:广度优先遍历BFS(Breadth First Search),深度优先遍历DFS(Depth First Search)</p><ul><li><p>广度优先遍历BFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思想:自上而下，将同一层结点遍历完后才开始遍历下一层结点</span></span><br><span class="line"><span class="comment">//时间复杂度为:O(n)-&gt;n是二叉树节点的数目,每个节点会被遍历一次</span></span><br><span class="line"><span class="comment">//空间复杂度为:O(n)</span></span><br><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="comment">//定义一棵二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义节点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">//定义左子树</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    <span class="comment">//定义右子树</span></span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="comment">//定义初始化方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空树判断</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">//使用队列来记录各层节点</span></span><br><span class="line">    queue.offer(root);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录树的深度</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();DDDDDDDDDDDDDDDDDDFDFD\P]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>深度优先遍历DFS的主要思想:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFS将会纵向遍历节点，在遍历每个节点时，即可得到当前节点至根节点的深度</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="二叉树" scheme="www.rickzhang.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2.两数相加</title>
    <link href="www.rickzhang.cn/2021/08/07/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>www.rickzhang.cn/2021/08/07/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-08-07T00:12:21.000Z</published>
    <updated>2021-08-07T00:12:22.005Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="www.rickzhang.cn/2021/08/07/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>www.rickzhang.cn/2021/08/07/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-08-06T23:46:46.000Z</published>
    <updated>2021-08-07T00:12:31.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力解法:给定一个数字,然后在数组中找出两个相加符合结果的数,首先得记录数组中有哪些数字,然后根据输入的数字来找另一个符合结果的数字,用一个for循环记录数组中出现过的数字,然后再用一个for循环遍历,寻找另一个符合结果的数字.</li><li>进阶解法: 利用暴力解法的时间复杂度为n2,为什么为n2呢?因为记录用了n,寻找用了n,则可以利用hashmap来替代,实现边记录边寻找.使用hashmap来进行进行实现,用数值做为key,用下标作为value,用一个for循环来遍历数组,每次遍历的时候检查一下hashmap里有没有符合条件的key,没有则加入hashmap,有则返回当前下标和检查到符合条件的下标.</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建一个hashmap表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//先找一下有没有符合条件的</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                    map.get(target - nums[i]),i</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有则加入hashmap</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>面试软技能</title>
    <link href="www.rickzhang.cn/2021/08/04/%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    <id>www.rickzhang.cn/2021/08/04/%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/</id>
    <published>2021-08-04T13:56:25.000Z</published>
    <updated>2021-08-04T13:56:25.562Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM篇</title>
    <link href="www.rickzhang.cn/2021/08/04/JVM%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/08/04/JVM%E7%AF%87/</id>
    <published>2021-08-04T09:08:51.000Z</published>
    <updated>2021-08-05T08:26:18.036Z</updated>
    
    <content type="html"><![CDATA[<p>JavaSE体系结构</p><p>JDK包含JRE JRE 包含JVM</p><p>什么是JVM</p><p>它可以说是一个翻译官,可以将字节码class文件翻译成操作系统上的指令</p><p>并不是只有java才能跑在JVM上,支持多种语言,只要是class文件即可,JVM是一种规范,虚构出来的计算机</p><p>为什么要学习JVM虚拟机</p><ul><li><p>编写高效优雅的java程序</p></li><li><p>排查问题,性能优化.例如:oom(内存溢出)</p></li><li><p>面试必问</p><p>JVM历史</p><p> JVM的整体介绍</p><ul><li>内存是JVM的五脏六腑</li><li>内存分配</li><li>垃圾回收</li></ul></li></ul><p>程序计数器</p><p>虚拟机栈</p><ul><li><p>存储当前线程运行方法时的</p><p>javap反编译</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaSE体系结构&lt;/p&gt;
&lt;p&gt;JDK包含JRE JRE 包含JVM&lt;/p&gt;
&lt;p&gt;什么是JVM&lt;/p&gt;
&lt;p&gt;它可以说是一个翻译官,可以将字节码class文件翻译成操作系统上的指令&lt;/p&gt;
&lt;p&gt;并不是只有java才能跑在JVM上,支持多种语言,只要是class文件即</summary>
      
    
    
    
    
    <category term="JVM" scheme="www.rickzhang.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>为什么迟迟没有读懂数据结构与算法</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-31T14:31:50.000Z</published>
    <updated>2021-07-31T14:31:50.385Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>你该懂的设计模式</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-31T14:31:07.000Z</published>
    <updated>2021-07-31T14:31:07.622Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小小刷题之旅</title>
    <link href="www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/"/>
    <id>www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/</id>
    <published>2021-07-23T05:28:13.000Z</published>
    <updated>2021-08-07T00:10:03.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力解法:给定一个数字,然后在数组中找出两个相加符合结果的数,首先得记录数组中有哪些数字,然后根据输入的数字来找另一个符合结果的数字,用一个for循环记录数组中出现过的数字,然后再用一个for循环遍历,寻找另一个符合结果的数字.</li><li>进阶解法: 利用暴力解法的时间复杂度为n2,为什么为n2呢?因为记录用了n,寻找用了n,则可以利用hashmap来替代,实现边记录边寻找.使用hashmap来进行进行实现,用数值做为key,用下标作为value,用一个for循环来遍历数组,每次遍历的时候检查一下hashmap里有没有符合条件的key,没有则加入hashmap,有则返回当前下标和检查到符合条件的下标.</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建一个hashmap表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//先找一下有没有符合条件的</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                    map.get(target - nums[i]),i</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有则加入hashmap</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>根据输入的数组,将其定义在数轴上,根据高度和宽度来计算最大面积,每次计算面积都是以最短高度为高,下标为宽,对于每一个数,要计算出它的面积最大值,依次类推,比较出最大则是最终结果,每次两条高中小的则移动.</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            max = Math.max(max, Math.min(height[l],height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &gt; height[r]) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法养成篇</title>
    <link href="www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/</id>
    <published>2021-07-23T05:27:53.000Z</published>
    <updated>2021-07-26T02:55:32.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评估算法优劣的核心指标是什么"><a href="#评估算法优劣的核心指标是什么" class="headerlink" title="评估算法优劣的核心指标是什么?"></a>评估算法优劣的核心指标是什么?</h2><ul><li>时间复杂度(流程决定)</li><li>额外空间复杂度(流程决定)</li><li>常数项时间(实现细节决定)</li></ul><h2 id="何为常数时间的操作"><a href="#何为常数时间的操作" class="headerlink" title="何为常数时间的操作?"></a>何为常数时间的操作?</h2><p>如果一个操作的执行时间不以具体样本量为转移,每次执行时间都是固定时间,那这样的操作称为常数时间的操作.<br>常见的常数时间的操作:</p><ul><li>常见的算术运算(+ - * / %等)</li><li>常见的位运算(&gt;&gt;(带符号右移) &gt;&gt;&gt;(不带符号右移) | &amp; ^) (&gt;&gt;与&gt;&gt;&gt;的区别 &gt;&gt;右移后符号位补上原来的符号位,&gt;&gt;&gt;则无论正负,都是补0,两者移动后总体位数不变)</li><li>赋值,比较,自增,自减等操作</li><li>数组寻址操作<br>总之执行时间固定的操作都是常数时间的操作<h2 id="如何确定算法流程的总操作数量与样本数量之间的表达式关系"><a href="#如何确定算法流程的总操作数量与样本数量之间的表达式关系" class="headerlink" title="如何确定算法流程的总操作数量与样本数量之间的表达式关系?"></a>如何确定算法流程的总操作数量与样本数量之间的表达式关系?</h2></li><li>想象该算法流程所处理的数据状况,要按照最差情况来</li><li>把整个流程彻底拆分为一个个基本动作,保证每个动作都是常数时间的操作</li><li>如果数据量为N,看看基本动作的数量和N是什么关系.<h2 id="如何确定算法流程的时间复杂度"><a href="#如何确定算法流程的时间复杂度" class="headerlink" title="如何确定算法流程的时间复杂度"></a>如何确定算法流程的时间复杂度</h2>当完成了表达式的建立,只要把最高阶项留下即可,低阶项都去掉,高阶项的系数也去掉,记为:O(忽略掉系数的高阶项)<br>N<em>2 == N&lt;&lt;1<br>N/2 == N&gt;&gt;1<br>N</em>2+1 == (N&lt;&lt;1)|1</li></ul><h2 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h2><p>对于时间复杂度,一个只剩下一个最高阶项,那这样的意义何在呢?</p><ul><li><p>当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。</p></li><li><p>它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。</p><p><strong>注意:</strong>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。</p><p>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？</p><p>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为输入参数的空间，不算额外空间。<br>作为输出结果的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。</p><p>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>算法思路</strong>:将索引为0的下标假设成最小值,与往后的数值比较,如果比索引为0的数值小,则交换位置,一轮下来则实现索引为0的下标为当前最小值,继续往后选择索引为1的下标,重复此操作<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//设置最小值在哪个位置上</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>算法思路:</strong> 假设数组的长度为N,从[0,N-1]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-1位置;从[0,N-2]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-2位置…</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr,i, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思路:</strong> 想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>…<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol><li><p>在一个有序数组中，找某个数是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);<span class="comment">//==mid = (L+R)/2</span></span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>在一个有序数组中，找&gt;=某个数最左侧的位置 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在arr上,找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>在一个有序数组中，找&lt;=某个数最右侧的位置 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a>异或运算符</h2><p><strong>用法</strong>: 无进位相加–&gt;即相同为0,不同为1</p><p><strong>性质:</strong> </p><ul><li><p>0^N == N  N^N ==0</p></li><li><p>满足交换律和结合律</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="不用额外变量交换两个数"><a href="#不用额外变量交换两个数" class="headerlink" title="不用额外变量交换两个数"></a>不用额外变量交换两个数</h4><p><strong>代码实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">1000</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h4 id="怎么把一个int类型的数，提取出最右侧的1来"><a href="#怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="怎么把一个int类型的数，提取出最右侧的1来"></a>怎么把一个int类型的数，提取出最右侧的1来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ero = 任意数;</span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor = a ^ b</span></span><br><span class="line"><span class="comment">// eor != 0</span></span><br><span class="line"><span class="comment">// eor必然有一个位置上是1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>); <span class="comment">// 提取出最右的1</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">onlyOne ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(onlyOne + <span class="string">" "</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单链表与双链表"><a href="#单链表与双链表" class="headerlink" title="单链表与双链表"></a>单链表与双链表</h3><h4 id="1-单链表和双链表如何反转"><a href="#1-单链表和双链表如何反转" class="headerlink" title="1.单链表和双链表如何反转"></a>1.单链表和双链表如何反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">head.last = next;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-把给定值都删除"><a href="#2-把给定值都删除" class="headerlink" title="2.把给定值都删除"></a>2.把给定值都删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">Node pre = head;</span><br><span class="line">Node cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur.value == num) &#123;</span><br><span class="line">pre.next = cur.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评估算法优劣的核心指标是什么&quot;&gt;&lt;a href=&quot;#评估算法优劣的核心指标是什么&quot; class=&quot;headerlink&quot; title=&quot;评估算法优劣的核心指标是什么?&quot;&gt;&lt;/a&gt;评估算法优劣的核心指标是什么?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间复杂度(流程决定)&lt;/l</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="www.rickzhang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试题</title>
    <link href="www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-07-22T02:43:35.000Z</published>
    <updated>2021-07-23T02:14:35.725Z</updated>
    
    
    
    
    
    <category term="面试" scheme="www.rickzhang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java多线程篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/</id>
    <published>2021-07-20T01:43:21.000Z</published>
    <updated>2021-07-20T03:45:59.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序运行资源分配的最小单位</p><p>线程则是CPU调度的最小单位,且必须依赖进程而存在<br>线程无处不在</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发:指应用能够交替执行不同的任务</p><p>并行:指应用能够同时执行不同的任务.</p><p><strong>两者区别:</strong> 一个是交替执行,一个是同时执行.</p><h2 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h2><ol><li>充分利用CPU资源</li><li>加快响应用户的时间</li><li>可以使代码模块化,异步化,简单化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程是程序运行资源分配的最小单位&lt;/p&gt;
&lt;p&gt;线程则是CPU调度的最小单位,且必须依赖进程而存在&lt;br&gt;线程无处不</summary>
      
    
    
    
    
    <category term="多线程" scheme="www.rickzhang.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-07-20T01:42:51.000Z</published>
    <updated>2021-07-20T01:42:51.574Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从排序矩阵查找到分治算法</title>
    <link href="www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-18T14:59:32.000Z</published>
    <updated>2021-07-19T02:52:20.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>维护一个行指针和一个列指针，利用分治算法，从右上角元素出发，比较目标元素与当前数值</p><ul><li>如果当前元素等于目标值，则返回true</li><li>如果当前元素小于目标值，则当前元素左侧的元素都会小于目标值，指针下移动</li><li>如果当前元素大于目标值，则当前元素右下方都会大于目标值，指针左移</li><li>如果指针在矩阵外，返回false  <h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length; <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始位置假设在右上角位置，定义一个行指针和一个列指针</span></span><br><span class="line">        <span class="keyword">int</span> currentRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentColumn = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentColumn &gt;= <span class="number">0</span> &amp;&amp; currentRow &lt; m) &#123;</span><br><span class="line">            <span class="comment">//当前元素等于目标值，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果当前元素小于目标值，则列指针下移</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] &lt; target) &#123;</span><br><span class="line">                currentRow++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果当前元素大于目标值，则列指针左移</span></span><br><span class="line">                currentColumn--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度:O(m+n)<br>空间复杂度:O(1)</li></ul><p>执行结果：<br>通过</p><p>执行用时：<br>5 ms<br>, 在所有 Java 提交中击败了<br>98.91%<br>的用户</p><p>内存消耗：<br>43.9 MB<br>, 在所有 Java 提交中击败了<br>52.11%<br>的用户</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>该题目使用双指针，并且利用了分治思维，那什么是分治算法呢？</p><ul><li>把复杂的问题分成两个或者更多的相同或者相似的子问题，直到子问题可直接求解，原问题的解即子问题的解的合并<br>分治法解题的一般步骤:</li><li>分解:将要解决的问题划分为若干规模较小的同类问题</li><li>求解:递归地求解各个子问题，当子问题划分得足够小时，用较简单的方法解决</li><li>合并:按原问题的要求，将子问题的解逐层合并构成原问题的解<h2 id="5-扩展题目"><a href="#5-扩展题目" class="headerlink" title="5. 扩展题目"></a>5. 扩展题目</h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。&lt;/p&gt;
&lt;h2 id=&quot;2-解题思路</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="分治" scheme="www.rickzhang.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK8的更新,你应该知道</title>
    <link href="www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/"/>
    <id>www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</id>
    <published>2021-07-15T15:04:24.000Z</published>
    <updated>2021-07-15T15:04:24.157Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从汉诺塔问题谈到递归</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/</id>
    <published>2021-07-14T10:19:19.000Z</published>
    <updated>2021-07-15T02:15:08.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>根据美国一学者提出的两步操作法：1.按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，2.把另外两根柱子上可以移动的圆盘移动到新的柱子上<br>• 把非空柱子上的圆盘移动到空柱子上<br>• 当两根柱子都非空时，移动较小的圆盘<br>重复以上操作即可，对于N层汉诺塔，有以下思路：• 如果我们能将上面的N-1层移动到B上<br>• 把N层移动到C，再把B上N-1层移动到C上就可以解决问题了<br>• 问题变为如何解决N-1层汉诺塔的移动问题<br>• 继续思考一直到N-1等于1时，我们可以直接将1层汉诺塔移动目的位置<br>可以选择递归来实现：<br>• 递归函数主功能<br>• 移动N-1个盘子到中间柱子<br>• 移动第N个盘子到目标柱子<br>• 将N-1个盘子从中间柱子移动到目标柱<br>子<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        movePlate(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">movePlate</span><span class="params">(<span class="keyword">int</span> size, List&lt;Integer&gt; start, List&lt;Integer&gt; auxiliary,List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 只剩⼀一个盘⼦子时，直接从第⼀一个柱⼦子移动到第三个柱⼦子 即可</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数主功能：移动n-1个盘⼦子，移动第n个盘⼦子，移动n-1个盘⼦子</span></span><br><span class="line">        <span class="comment">// 等价关系式 f(n , A , B , C)=f(n-1,A,C,B)+M(A,C)+f(n-1, B,A,C)</span></span><br><span class="line">        <span class="comment">// 将 n-1 个盘⼦子，从 第⼀一个柱⼦子 移动到 第⼆二个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,start,target,auxiliary);</span><br><span class="line">        <span class="comment">// 将第 n个盘⼦子，从 第⼀一个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 再将 n-1 个盘⼦子，从 第⼆二个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,auxiliary,start,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：通过</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.4 MB, 在所有 Java 提交中击败了45.35%的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="递归" scheme="www.rickzhang.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>你应该懂的排序</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-14T01:45:13.000Z</published>
    <updated>2021-07-14T13:57:16.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[begin] &lt; arr[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[begin];</span><br><span class="line">                arr[begin] = arr[begin - <span class="number">1</span>];</span><br><span class="line">                arr[begin - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n2)</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[j] &gt; temp)) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) arr[j] =temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡排序&quot;&gt;&lt;/a&gt;1. 冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    
    <category term="排序" scheme="www.rickzhang.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>springcloud使用</title>
    <link href="www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/"/>
    <id>www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-10T06:29:39.000Z</published>
    <updated>2021-07-13T06:22:08.158Z</updated>
    
    <content type="html"><![CDATA[<p>nacos注册中心<br>使用方式：<br>1.为项目导入alibaba的依赖<br>2.导入nacos的依赖<br>3.在main加注解<br>4.需要给每一个微服务加上自己的名字</p><p>想要远程调用别的服务<br>1.引入open-feign<br>2.编写一个接口，告诉springcloud这个接口需要调用远程服务<br>3.声明接口的每一个方法都是调用哪个远程服务的那个请求<br>4.开启远程调用功能<br>远程调用注意版本：<a href="https://blog.csdn.net/weixin_45729934/article/details/110310119" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45729934/article/details/110310119</a></p><p>nacos作为配置中心<br>1.导入pom：nacos config starter<br>2.创建配置文件：bootstrap.properties<br>3.在127.0.0.1：8848中创建配置文件：项目名.properties<br>4.在controller加上@RefreshScope—-动态刷新</p><p>API网关</p><p>vue<br>初始化：npm init -y<br>安装vue依赖：npm install vue</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nacos注册中心&lt;br&gt;使用方式：&lt;br&gt;1.为项目导入alibaba的依赖&lt;br&gt;2.导入nacos的依赖&lt;br&gt;3.在main加注解&lt;br&gt;4.需要给每一个微服务加上自己的名字&lt;/p&gt;
&lt;p&gt;想要远程调用别的服务&lt;br&gt;1.引入open-feign&lt;br&gt;2.编写一个</summary>
      
    
    
    
    
    <category term="springcloud" scheme="www.rickzhang.cn/tags/springcloud/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-11-02T08:30:07.658Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>41.缺失的第一个正数</title>
    <link href="www.rickzhang.cn/2021/11/02/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>www.rickzhang.cn/2021/11/02/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</id>
    <published>2021-11-02T07:57:01.000Z</published>
    <updated>2021-11-02T08:30:07.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>首先从题意可得，题目会提供一个未排完序的数组，然后要求我们找出其中没有出现的最小的正整数，那么在这里我们应该想到最小的正整数是啥—1，那对于这道题我们可以这样想，是不是找出最小的数，然后跟最小的正整数相比，结果不就出来了吗？但是题目可是要求时间复杂度为O(n)哦，如果使用排序，可达不到这样的复杂度。</li><li>我们可以假设数组上的每一个位置都存放着i+1，i为数组下标，那如果这种情况一直没实现，是不是意味着i+1没出现过？</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先定义一个变量l，从<span class="number">0</span>开始，再定义一个变量r，初始值等于arr.length,数组从l开始遍历，进行双指针的遍历，如果出现(arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]),则arr[l]与arr[--r]进行互换(为啥是--r--初始值问题),剩下则采取arr[l]与arr[arr[l]-<span class="number">1</span>]互换;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = arr.length;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] == l + <span class="number">1</span>) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &lt;= l || arr[l] &gt; r || arr[arr[l] - <span class="number">1</span>] == arr[l]) &#123;</span><br><span class="line">swap(arr,l,--r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, l, arr[l] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;请你实现</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>给定一个链表的头结点head，判断该链表是否为回文结构</title>
    <link href="www.rickzhang.cn/2021/10/11/%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9head%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>www.rickzhang.cn/2021/10/11/%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9head%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/</id>
    <published>2021-10-11T12:21:15.000Z</published>
    <updated>2021-10-13T12:03:07.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题解"><a href="#1-题解" class="headerlink" title="1. 题解"></a>1. 题解</h2><h3 id="什么是回文结构？"><a href="#什么是回文结构？" class="headerlink" title="什么是回文结构？"></a>什么是回文结构？</h3><p>正序与逆序一样</p><h3 id="突破点"><a href="#突破点" class="headerlink" title="突破点"></a>突破点</h3><ul><li><p>如果链表为奇数，则可将链表在中点位置切割为两部分，分别在两边同时进行遍历，并一一比较，一旦有不相等的，就跳出程序</p></li><li><p>如果为偶数，也是从两头开始遍历，一一比较，不相等则跳出程序</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><h3 id="1-实现1"><a href="#1-实现1" class="headerlink" title="1. 实现1"></a>1. 实现1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：将元素一一存入栈中，再让栈弹出，每次弹出的时候与原始链表进行比较，一旦不相等则return，利用了栈的先进后出特性，实现链表元素的逆序 */</span></span><br><span class="line"><span class="comment">//空间复杂度为（n）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明一个栈</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//声明一个变量指向头结点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//将元素放入栈中</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行元素的比较</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针往后移</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现2"><a href="#2-实现2" class="headerlink" title="2. 实现2"></a>2. 实现2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题解&quot;&gt;&lt;a href=&quot;#1-题解&quot; class=&quot;headerlink&quot; title=&quot;1. 题解&quot;&gt;&lt;/a&gt;1. 题解&lt;/h2&gt;&lt;h3 id=&quot;什么是回文结构？&quot;&gt;&lt;a href=&quot;#什么是回文结构？&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="链表" scheme="www.rickzhang.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JWT从入门到使用</title>
    <link href="www.rickzhang.cn/2021/10/02/JWT%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8/"/>
    <id>www.rickzhang.cn/2021/10/02/JWT%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-02T07:51:33.000Z</published>
    <updated>2021-10-02T11:53:40.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1. 什么是JWT"></a>1. 什么是JWT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JWT即JSON Web Token，就是以Json形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</span><br></pre></td></tr></table></figure><h2 id="2-JWT的作用"><a href="#2-JWT的作用" class="headerlink" title="2. JWT的作用"></a>2. JWT的作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于授权，旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。</span><br></pre></td></tr></table></figure><h2 id="3-为什么选择JWT"><a href="#3-为什么选择JWT" class="headerlink" title="3. 为什么选择JWT"></a>3. 为什么选择JWT</h2><ol><li><p>相对于传统的Session认证，JWT可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p></li><li><p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li><li><p>Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持</p></li><li><p>不需要在服务端保存会话信息，特别适用于分布式微服务</p></li></ol><h2 id="4-JWT的结构"><a href="#4-JWT的结构" class="headerlink" title="4. JWT的结构"></a>4. JWT的结构</h2><p><strong>JWT主要由</strong>：</p><ol><li><p>标头（Header）</p><p>标头通常由两部分组成：令牌的类型和所使用的签名算法，例如HMAC、SHA256或RSA，通常它会使用Base64编码组成JWT结构的第一部分，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">    <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有效载荷（Payload）</p><p>令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>签名（Signature）</p><p>前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">"."</span> + base64UrlEncode(payload),secret);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">签名的目的：</span><br><span class="line">最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</span><br></pre></td></tr></table></figure><p>PS:Base64是一种编码，是可逆的,所以，在JWT中，不应该在负载里面加入任何敏感的数据。</p><p>因此，JWT通常表示为：</p><p>xxxx.yyyy.zzzz====&gt;header.payload.signature</p></li></ol><h2 id="5-如何使用JWT"><a href="#5-如何使用JWT" class="headerlink" title="5. 如何使用JWT"></a>5. 如何使用JWT</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1. 导入依赖"></a>1. 导入依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入jwt--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2. 生成token"></a>2. 生成token</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar instance = Calendar.getInstance();<span class="comment">//利用日期类</span></span><br><span class="line">instance.add(Calendar.SECOND, <span class="number">90</span>);<span class="comment">//设置指定间隔后的时间</span></span><br><span class="line"><span class="comment">//生成令牌</span></span><br><span class="line">String token = JWT.create()</span><br><span class="line">    .withClaim(<span class="string">"username"</span>,<span class="string">"张三"</span>)<span class="comment">//设置自定义用户名-&gt;Payload</span></span><br><span class="line">    .withExpiresAT(instance.getTime())<span class="comment">//设置过期时间</span></span><br><span class="line">    .sign(Algorithm.HMAC256(<span class="string">"asdfsadf"</span>));<span class="comment">//利用Algorithm算法设置使用的加密算法，使用的密钥为：asdfsadf。--&gt;设置Signature</span></span><br><span class="line"><span class="comment">//JWT有三大结构，为什么只设置Payload和Signature呢？因为header会有一个默认值</span></span><br><span class="line">System.out.println(token);<span class="comment">//输出token</span></span><br></pre></td></tr></table></figure><h3 id="3-根据token和签名对数据进行解析"><a href="#3-根据token和签名对数据进行解析" class="headerlink" title="3. 根据token和签名对数据进行解析"></a>3. 根据token和签名对数据进行解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(<span class="string">"token!Q2W#E$RW"</span>)).build();<span class="comment">//指定加密的算法和密钥</span></span><br><span class="line">DecodedJWT decodedJWT = jwtVerifier.verify(token);<span class="comment">//对token进行验证，如果无误则不会报错，验证错误则会报错，至于报什么错对应什么问题，看下文</span></span><br><span class="line">System.out.println(<span class="string">"用户名: "</span> + decodedJWT.getClaim(<span class="string">"username"</span>).asString());</span><br><span class="line">System.out.println(<span class="string">"过期时间: "</span>+decodedJWT.getExpiresAt());</span><br></pre></td></tr></table></figure><h3 id="4-使用JWT常见的异常信息"><a href="#4-使用JWT常见的异常信息" class="headerlink" title="4. 使用JWT常见的异常信息"></a>4. 使用JWT常见的异常信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- SignatureVerificationException:签名不一致异常</span><br><span class="line">- TokenExpiredException:    令牌过期异常</span><br><span class="line">- AlgorithmMismatchException:算法不匹配异常</span><br><span class="line">- InvalidClaimException:失效的payload异常</span><br></pre></td></tr></table></figure><h2 id="6-封装成Util类"><a href="#6-封装成Util类" class="headerlink" title="6. 封装成Util类"></a>6. 封装成Util类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOKEN = <span class="string">"token!Q@W3e4r"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  //传入payload</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">        JWTCreator.Builder builder = JWT.create();</span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            builder.withClaim(k,v);</span><br><span class="line">        &#125;);</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.add(Calendar.SECOND,<span class="number">7</span>);</span><br><span class="line">        builder.withExpiresAt(instance.getTime());</span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(TOKEN)).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中payload</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title">getToken</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-整合springboot"><a href="#7-整合springboot" class="headerlink" title="7. 整合springboot"></a>7. 整合springboot</h2><p>在springboot的使用当中，通常会创建一个拦截器来对token进行验证</p><p>实现拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.AlgorithmMismatchException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.SignatureVerificationException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.TokenExpiredException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> com.baizhi.utils.JWTUtils;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取请求头中令牌</span></span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JWTUtils.verify(token);<span class="comment">//验证令牌</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//放行请求</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SignatureVerificationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"无效签名!"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (TokenExpiredException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"token过期!"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AlgorithmMismatchException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"token算法不一致!"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            map.put(<span class="string">"msg"</span>,<span class="string">"token无效!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(<span class="string">"state"</span>,<span class="keyword">false</span>);<span class="comment">//设置状态</span></span><br><span class="line">        <span class="comment">//将map 专为json  jackson</span></span><br><span class="line">        String json = <span class="keyword">new</span> ObjectMapper().writeValueAsString(map);</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        response.getWriter().println(json);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baizhi.interceptors.JWTInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> JWTInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/user/test"</span>)         <span class="comment">//其他接口token验证</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/user/login"</span>);  <span class="comment">//所有用户都放心</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是JWT&quot;&gt;&lt;a href=&quot;#1-什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是JWT&quot;&gt;&lt;/a&gt;1. 什么是JWT&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="JWT" scheme="www.rickzhang.cn/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="www.rickzhang.cn/2021/09/12/java%E5%9F%BA%E7%A1%80/"/>
    <id>www.rickzhang.cn/2021/09/12/java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-12T08:23:49.000Z</published>
    <updated>2021-09-12T10:20:56.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础面试题集"><a href="#java基础面试题集" class="headerlink" title="java基础面试题集"></a>java基础面试题集</h1><h2 id="1-与equals的区别"><a href="#1-与equals的区别" class="headerlink" title="1. ==与equals的区别"></a>1. ==与equals的区别</h2><h2 id="2-java八大基本类型"><a href="#2-java八大基本类型" class="headerlink" title="2. java八大基本类型"></a>2. java八大基本类型</h2><h2 id="3-重写与重载的区别"><a href="#3-重写与重载的区别" class="headerlink" title="3. 重写与重载的区别"></a>3. 重写与重载的区别</h2><h2 id="4-String类型题目"><a href="#4-String类型题目" class="headerlink" title="4. String类型题目"></a>4. String类型题目</h2><h2 id="5-接口抽象类"><a href="#5-接口抽象类" class="headerlink" title="5. 接口抽象类"></a>5. 接口抽象类</h2><h2 id="6-集合"><a href="#6-集合" class="headerlink" title="6. 集合"></a>6. 集合</h2><h2 id="7-为什么重写equals还要重写hashCode"><a href="#7-为什么重写equals还要重写hashCode" class="headerlink" title="7. 为什么重写equals还要重写hashCode"></a>7. 为什么重写equals还要重写hashCode</h2><ul><li><p>hashCode是由c语言编写的</p></li><li><p>因为Set存储的是不重复对象，依据hashCode和equals进行判断，</p></li><li><p>如果是自定义对象作为Map键，那么也必须重写hashCode和equals</p></li><li><p>String已重写了hashCode和equals</p></li><li><p>避免内存泄漏</p></li><li><p>如果两个对象的hashCode值相等，则对象内容不一定相等，会产生hash碰撞问题</p></li><li><p>如果使用equals方法比较两个对象内容值相等的情况下，则两个对象的hashCode值相等。</p></li><li><p>如果避免内存泄漏</p><h2 id="8-HashMap与HashTable"><a href="#8-HashMap与HashTable" class="headerlink" title="8. HashMap与HashTable"></a>8. HashMap与HashTable</h2><p>HashMap线程不安全，允许存放key为null，放在数组0的位置</p><h2 id="9-String、StringBuffer、StringBuilder区别与联系"><a href="#9-String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="9. String、StringBuffer、StringBuilder区别与联系"></a>9. String、StringBuffer、StringBuilder区别与联系</h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java基础面试题集&quot;&gt;&lt;a href=&quot;#java基础面试题集&quot; class=&quot;headerlink&quot; title=&quot;java基础面试题集&quot;&gt;&lt;/a&gt;java基础面试题集&lt;/h1&gt;&lt;h2 id=&quot;1-与equals的区别&quot;&gt;&lt;a href=&quot;#1-与equals</summary>
      
    
    
    
    
    <category term="面试" scheme="www.rickzhang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树总结</title>
    <link href="www.rickzhang.cn/2021/08/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <id>www.rickzhang.cn/2021/08/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-22T14:56:30.000Z</published>
    <updated>2021-09-01T16:01:03.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Node &#123;</span><br><span class="line">    V value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历方式"><a href="#2-遍历方式" class="headerlink" title="2. 遍历方式"></a>2. 遍历方式</h3><h4 id="常见的先、中、后序遍历"><a href="#常见的先、中、后序遍历" class="headerlink" title="常见的先、中、后序遍历"></a>常见的先、中、后序遍历</h4><ol><li><p>先序遍历</p><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        reruen;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    pre(head.left);</span><br><span class="line">    pre(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现思路</span></span><br><span class="line"><span class="comment">/**  1. 栈顶先入栈，弹出打印</span></span><br><span class="line"><span class="comment"> *   2. 如有右，压入右</span></span><br><span class="line"><span class="comment"> *   3. 如有左，压入左</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pre-order:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;;</span><br><span class="line">        stack.add(head); </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty) &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">          <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>中序遍历</p><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in(head.left);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    in(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 实现思路</span></span><br><span class="line"> <span class="comment">/**  1. 整条左边界依次入栈</span></span><br><span class="line"><span class="comment">*   2. 1.无法执行，则弹出</span></span><br><span class="line"><span class="comment">  *   3. 右边进</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">     System.out.print(<span class="string">"in-order:"</span>);</span><br><span class="line">     <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">         <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 stack.push(head);</span><br><span class="line">                 head = head.left;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 head = stack.pop();</span><br><span class="line">                 System.out.print(head.value + <span class="string">""</span>);</span><br><span class="line">                 head = head.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="3"><li><p>后序遍历</p><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos(head.left);</span><br><span class="line">    pos(head.right);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 实现思路</span></span><br><span class="line">    <span class="comment">/**  1. 先序遍历反过来</span></span><br><span class="line"><span class="comment">*   2. 注意：因为该后序遍历是通过另一个栈来实现，栈是先进后出，所以前序的进栈顺序得   *改变一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"pos-order:"</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">            Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">            s1.push(head);</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                head = s1.pop();</span><br><span class="line">                s2.push(head);</span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s1.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s1.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历s2栈</span></span><br><span class="line">            <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">                System.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1.</summary>
      
    
    
    
    
    <category term="数据结构" scheme="www.rickzhang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>17.电话号码的字母组合</title>
    <link href="www.rickzhang.cn/2021/08/15/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>www.rickzhang.cn/2021/08/15/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2021-08-15T01:11:27.000Z</published>
    <updated>2021-08-15T01:11:27.018Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>15.三数之和</title>
    <link href="www.rickzhang.cn/2021/08/14/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>www.rickzhang.cn/2021/08/14/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-08-14T01:45:46.000Z</published>
    <updated>2021-08-14T01:45:46.924Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>14.最长公共前缀</title>
    <link href="www.rickzhang.cn/2021/08/10/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>www.rickzhang.cn/2021/08/10/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2021-08-10T07:56:57.000Z</published>
    <updated>2021-08-10T07:56:57.592Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="www.rickzhang.cn/2021/08/10/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>www.rickzhang.cn/2021/08/10/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2021-08-10T07:56:23.000Z</published>
    <updated>2021-08-10T07:56:23.161Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>104.二叉树的最大深度</title>
    <link href="www.rickzhang.cn/2021/08/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>www.rickzhang.cn/2021/08/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2021-08-08T08:30:03.000Z</published>
    <updated>2021-08-10T15:31:15.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例</strong></p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>对于二叉树求深度主要的遍历方式有:广度优先遍历BFS(Breadth First Search),深度优先遍历DFS(Depth First Search)</p><ul><li><p>广度优先遍历BFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思想:自上而下，将同一层结点遍历完后才开始遍历下一层结点</span></span><br><span class="line"><span class="comment">//时间复杂度为:O(n)-&gt;n是二叉树节点的数目,每个节点会被遍历一次</span></span><br><span class="line"><span class="comment">//空间复杂度为:O(n)</span></span><br><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="comment">//定义一棵二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义节点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">//定义左子树</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    <span class="comment">//定义右子树</span></span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="comment">//定义初始化方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空树判断</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">//使用队列来记录各层节点</span></span><br><span class="line">    queue.offer(root);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录树的深度</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();DDDDDDDDDDDDDDDDDDFDFD\P]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>深度优先遍历DFS的主要思想:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFS将会纵向遍历节点，在遍历每个节点时，即可得到当前节点至根节点的深度</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="二叉树" scheme="www.rickzhang.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2.两数相加</title>
    <link href="www.rickzhang.cn/2021/08/07/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>www.rickzhang.cn/2021/08/07/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-08-07T00:12:21.000Z</published>
    <updated>2021-08-17T02:13:57.465Z</updated>
    
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="www.rickzhang.cn/2021/08/07/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>www.rickzhang.cn/2021/08/07/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-08-06T23:46:46.000Z</published>
    <updated>2021-08-17T01:56:27.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力解法:给定一个数字,然后在数组中找出两个相加符合结果的数,首先得记录数组中有哪些数字,然后根据输入的数字来找另一个符合结果的数字,用一个for循环记录数组中出现过的数字,然后再用一个for循环遍历,寻找另一个符合结果的数字.</li><li>进阶解法: 利用暴力解法的时间复杂度为n2,为什么为n2呢?因为记录用了n,寻找用了n,则可以利用hashmap来替代,实现边记录边寻找.使用hashmap来进行进行实现,用数值做为key,用下标作为value,用一个for循环来遍历数组,每次遍历的时候检查一下hashmap里有没有符合条件的key,没有则加入hashmap,有则返回当前下标和检查到符合条件的下标.</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建一个hashmap表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//先找一下有没有符合条件的</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                    map.get(target - nums[i]),i</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有则加入hashmap</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>面试软技能</title>
    <link href="www.rickzhang.cn/2021/08/04/%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    <id>www.rickzhang.cn/2021/08/04/%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/</id>
    <published>2021-08-04T13:56:25.000Z</published>
    <updated>2021-08-04T13:56:25.562Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM篇</title>
    <link href="www.rickzhang.cn/2021/08/04/JVM%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/08/04/JVM%E7%AF%87/</id>
    <published>2021-08-04T09:08:51.000Z</published>
    <updated>2021-08-05T08:26:18.036Z</updated>
    
    <content type="html"><![CDATA[<p>JavaSE体系结构</p><p>JDK包含JRE JRE 包含JVM</p><p>什么是JVM</p><p>它可以说是一个翻译官,可以将字节码class文件翻译成操作系统上的指令</p><p>并不是只有java才能跑在JVM上,支持多种语言,只要是class文件即可,JVM是一种规范,虚构出来的计算机</p><p>为什么要学习JVM虚拟机</p><ul><li><p>编写高效优雅的java程序</p></li><li><p>排查问题,性能优化.例如:oom(内存溢出)</p></li><li><p>面试必问</p><p>JVM历史</p><p> JVM的整体介绍</p><ul><li>内存是JVM的五脏六腑</li><li>内存分配</li><li>垃圾回收</li></ul></li></ul><p>程序计数器</p><p>虚拟机栈</p><ul><li><p>存储当前线程运行方法时的</p><p>javap反编译</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaSE体系结构&lt;/p&gt;
&lt;p&gt;JDK包含JRE JRE 包含JVM&lt;/p&gt;
&lt;p&gt;什么是JVM&lt;/p&gt;
&lt;p&gt;它可以说是一个翻译官,可以将字节码class文件翻译成操作系统上的指令&lt;/p&gt;
&lt;p&gt;并不是只有java才能跑在JVM上,支持多种语言,只要是class文件即</summary>
      
    
    
    
    
    <category term="JVM" scheme="www.rickzhang.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>为什么迟迟没有读懂数据结构与算法</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-31T14:31:50.000Z</published>
    <updated>2021-07-31T14:31:50.385Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>你该懂的设计模式</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-31T14:31:07.000Z</published>
    <updated>2021-07-31T14:31:07.622Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小小刷题之旅</title>
    <link href="www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/"/>
    <id>www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/</id>
    <published>2021-07-23T05:28:13.000Z</published>
    <updated>2021-08-07T00:10:03.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力解法:给定一个数字,然后在数组中找出两个相加符合结果的数,首先得记录数组中有哪些数字,然后根据输入的数字来找另一个符合结果的数字,用一个for循环记录数组中出现过的数字,然后再用一个for循环遍历,寻找另一个符合结果的数字.</li><li>进阶解法: 利用暴力解法的时间复杂度为n2,为什么为n2呢?因为记录用了n,寻找用了n,则可以利用hashmap来替代,实现边记录边寻找.使用hashmap来进行进行实现,用数值做为key,用下标作为value,用一个for循环来遍历数组,每次遍历的时候检查一下hashmap里有没有符合条件的key,没有则加入hashmap,有则返回当前下标和检查到符合条件的下标.</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建一个hashmap表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//先找一下有没有符合条件的</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                    map.get(target - nums[i]),i</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有则加入hashmap</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>根据输入的数组,将其定义在数轴上,根据高度和宽度来计算最大面积,每次计算面积都是以最短高度为高,下标为宽,对于每一个数,要计算出它的面积最大值,依次类推,比较出最大则是最终结果,每次两条高中小的则移动.</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            max = Math.max(max, Math.min(height[l],height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &gt; height[r]) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法养成篇</title>
    <link href="www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/</id>
    <published>2021-07-23T05:27:53.000Z</published>
    <updated>2021-07-26T02:55:32.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评估算法优劣的核心指标是什么"><a href="#评估算法优劣的核心指标是什么" class="headerlink" title="评估算法优劣的核心指标是什么?"></a>评估算法优劣的核心指标是什么?</h2><ul><li>时间复杂度(流程决定)</li><li>额外空间复杂度(流程决定)</li><li>常数项时间(实现细节决定)</li></ul><h2 id="何为常数时间的操作"><a href="#何为常数时间的操作" class="headerlink" title="何为常数时间的操作?"></a>何为常数时间的操作?</h2><p>如果一个操作的执行时间不以具体样本量为转移,每次执行时间都是固定时间,那这样的操作称为常数时间的操作.<br>常见的常数时间的操作:</p><ul><li>常见的算术运算(+ - * / %等)</li><li>常见的位运算(&gt;&gt;(带符号右移) &gt;&gt;&gt;(不带符号右移) | &amp; ^) (&gt;&gt;与&gt;&gt;&gt;的区别 &gt;&gt;右移后符号位补上原来的符号位,&gt;&gt;&gt;则无论正负,都是补0,两者移动后总体位数不变)</li><li>赋值,比较,自增,自减等操作</li><li>数组寻址操作<br>总之执行时间固定的操作都是常数时间的操作<h2 id="如何确定算法流程的总操作数量与样本数量之间的表达式关系"><a href="#如何确定算法流程的总操作数量与样本数量之间的表达式关系" class="headerlink" title="如何确定算法流程的总操作数量与样本数量之间的表达式关系?"></a>如何确定算法流程的总操作数量与样本数量之间的表达式关系?</h2></li><li>想象该算法流程所处理的数据状况,要按照最差情况来</li><li>把整个流程彻底拆分为一个个基本动作,保证每个动作都是常数时间的操作</li><li>如果数据量为N,看看基本动作的数量和N是什么关系.<h2 id="如何确定算法流程的时间复杂度"><a href="#如何确定算法流程的时间复杂度" class="headerlink" title="如何确定算法流程的时间复杂度"></a>如何确定算法流程的时间复杂度</h2>当完成了表达式的建立,只要把最高阶项留下即可,低阶项都去掉,高阶项的系数也去掉,记为:O(忽略掉系数的高阶项)<br>N<em>2 == N&lt;&lt;1<br>N/2 == N&gt;&gt;1<br>N</em>2+1 == (N&lt;&lt;1)|1</li></ul><h2 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h2><p>对于时间复杂度,一个只剩下一个最高阶项,那这样的意义何在呢?</p><ul><li><p>当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。</p></li><li><p>它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。</p><p><strong>注意:</strong>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。</p><p>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？</p><p>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为输入参数的空间，不算额外空间。<br>作为输出结果的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。</p><p>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>算法思路</strong>:将索引为0的下标假设成最小值,与往后的数值比较,如果比索引为0的数值小,则交换位置,一轮下来则实现索引为0的下标为当前最小值,继续往后选择索引为1的下标,重复此操作<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//设置最小值在哪个位置上</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>算法思路:</strong> 假设数组的长度为N,从[0,N-1]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-1位置;从[0,N-2]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-2位置…</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr,i, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思路:</strong> 想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>…<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol><li><p>在一个有序数组中，找某个数是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);<span class="comment">//==mid = (L+R)/2</span></span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>在一个有序数组中，找&gt;=某个数最左侧的位置 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在arr上,找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>在一个有序数组中，找&lt;=某个数最右侧的位置 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a>异或运算符</h2><p><strong>用法</strong>: 无进位相加–&gt;即相同为0,不同为1</p><p><strong>性质:</strong> </p><ul><li><p>0^N == N  N^N ==0</p></li><li><p>满足交换律和结合律</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="不用额外变量交换两个数"><a href="#不用额外变量交换两个数" class="headerlink" title="不用额外变量交换两个数"></a>不用额外变量交换两个数</h4><p><strong>代码实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">1000</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h4 id="怎么把一个int类型的数，提取出最右侧的1来"><a href="#怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="怎么把一个int类型的数，提取出最右侧的1来"></a>怎么把一个int类型的数，提取出最右侧的1来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ero = 任意数;</span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor = a ^ b</span></span><br><span class="line"><span class="comment">// eor != 0</span></span><br><span class="line"><span class="comment">// eor必然有一个位置上是1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>); <span class="comment">// 提取出最右的1</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">onlyOne ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(onlyOne + <span class="string">" "</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单链表与双链表"><a href="#单链表与双链表" class="headerlink" title="单链表与双链表"></a>单链表与双链表</h3><h4 id="1-单链表和双链表如何反转"><a href="#1-单链表和双链表如何反转" class="headerlink" title="1.单链表和双链表如何反转"></a>1.单链表和双链表如何反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">head.last = next;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-把给定值都删除"><a href="#2-把给定值都删除" class="headerlink" title="2.把给定值都删除"></a>2.把给定值都删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">Node pre = head;</span><br><span class="line">Node cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur.value == num) &#123;</span><br><span class="line">pre.next = cur.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评估算法优劣的核心指标是什么&quot;&gt;&lt;a href=&quot;#评估算法优劣的核心指标是什么&quot; class=&quot;headerlink&quot; title=&quot;评估算法优劣的核心指标是什么?&quot;&gt;&lt;/a&gt;评估算法优劣的核心指标是什么?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间复杂度(流程决定)&lt;/l</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="www.rickzhang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试题</title>
    <link href="www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-07-22T02:43:35.000Z</published>
    <updated>2021-07-23T02:14:35.725Z</updated>
    
    
    
    
    
    <category term="面试" scheme="www.rickzhang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java多线程篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/</id>
    <published>2021-07-20T01:43:21.000Z</published>
    <updated>2021-07-20T03:45:59.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序运行资源分配的最小单位</p><p>线程则是CPU调度的最小单位,且必须依赖进程而存在<br>线程无处不在</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发:指应用能够交替执行不同的任务</p><p>并行:指应用能够同时执行不同的任务.</p><p><strong>两者区别:</strong> 一个是交替执行,一个是同时执行.</p><h2 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h2><ol><li>充分利用CPU资源</li><li>加快响应用户的时间</li><li>可以使代码模块化,异步化,简单化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程是程序运行资源分配的最小单位&lt;/p&gt;
&lt;p&gt;线程则是CPU调度的最小单位,且必须依赖进程而存在&lt;br&gt;线程无处不</summary>
      
    
    
    
    
    <category term="多线程" scheme="www.rickzhang.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-07-22T02:43:35.271Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础面试题</title>
    <link href="www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-07-22T02:43:35.000Z</published>
    <updated>2021-07-22T02:43:35.271Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>java多线程篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/</id>
    <published>2021-07-20T01:43:21.000Z</published>
    <updated>2021-07-20T03:45:59.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序运行资源分配的最小单位</p><p>线程则是CPU调度的最小单位,且必须依赖进程而存在<br>线程无处不在</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发:指应用能够交替执行不同的任务</p><p>并行:指应用能够同时执行不同的任务.</p><p><strong>两者区别:</strong> 一个是交替执行,一个是同时执行.</p><h2 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h2><ol><li>充分利用CPU资源</li><li>加快响应用户的时间</li><li>可以使代码模块化,异步化,简单化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程是程序运行资源分配的最小单位&lt;/p&gt;
&lt;p&gt;线程则是CPU调度的最小单位,且必须依赖进程而存在&lt;br&gt;线程无处不</summary>
      
    
    
    
    
    <category term="多线程" scheme="www.rickzhang.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-07-20T01:42:51.000Z</published>
    <updated>2021-07-20T01:42:51.574Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从排序矩阵查找到分治算法</title>
    <link href="www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-18T14:59:32.000Z</published>
    <updated>2021-07-19T02:52:20.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>维护一个行指针和一个列指针，利用分治算法，从右上角元素出发，比较目标元素与当前数值</p><ul><li>如果当前元素等于目标值，则返回true</li><li>如果当前元素小于目标值，则当前元素左侧的元素都会小于目标值，指针下移动</li><li>如果当前元素大于目标值，则当前元素右下方都会大于目标值，指针左移</li><li>如果指针在矩阵外，返回false  <h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length; <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始位置假设在右上角位置，定义一个行指针和一个列指针</span></span><br><span class="line">        <span class="keyword">int</span> currentRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentColumn = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentColumn &gt;= <span class="number">0</span> &amp;&amp; currentRow &lt; m) &#123;</span><br><span class="line">            <span class="comment">//当前元素等于目标值，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果当前元素小于目标值，则列指针下移</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] &lt; target) &#123;</span><br><span class="line">                currentRow++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果当前元素大于目标值，则列指针左移</span></span><br><span class="line">                currentColumn--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度:O(m+n)<br>空间复杂度:O(1)</li></ul><p>执行结果：<br>通过</p><p>执行用时：<br>5 ms<br>, 在所有 Java 提交中击败了<br>98.91%<br>的用户</p><p>内存消耗：<br>43.9 MB<br>, 在所有 Java 提交中击败了<br>52.11%<br>的用户</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>该题目使用双指针，并且利用了分治思维，那什么是分治算法呢？</p><ul><li>把复杂的问题分成两个或者更多的相同或者相似的子问题，直到子问题可直接求解，原问题的解即子问题的解的合并<br>分治法解题的一般步骤:</li><li>分解:将要解决的问题划分为若干规模较小的同类问题</li><li>求解:递归地求解各个子问题，当子问题划分得足够小时，用较简单的方法解决</li><li>合并:按原问题的要求，将子问题的解逐层合并构成原问题的解<h2 id="5-扩展题目"><a href="#5-扩展题目" class="headerlink" title="5. 扩展题目"></a>5. 扩展题目</h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。&lt;/p&gt;
&lt;h2 id=&quot;2-解题思路</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="分治" scheme="www.rickzhang.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK8的更新,你应该知道</title>
    <link href="www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/"/>
    <id>www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</id>
    <published>2021-07-15T15:04:24.000Z</published>
    <updated>2021-07-15T15:04:24.157Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从汉诺塔问题谈到递归</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/</id>
    <published>2021-07-14T10:19:19.000Z</published>
    <updated>2021-07-15T02:15:08.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>根据美国一学者提出的两步操作法：1.按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，2.把另外两根柱子上可以移动的圆盘移动到新的柱子上<br>• 把非空柱子上的圆盘移动到空柱子上<br>• 当两根柱子都非空时，移动较小的圆盘<br>重复以上操作即可，对于N层汉诺塔，有以下思路：• 如果我们能将上面的N-1层移动到B上<br>• 把N层移动到C，再把B上N-1层移动到C上就可以解决问题了<br>• 问题变为如何解决N-1层汉诺塔的移动问题<br>• 继续思考一直到N-1等于1时，我们可以直接将1层汉诺塔移动目的位置<br>可以选择递归来实现：<br>• 递归函数主功能<br>• 移动N-1个盘子到中间柱子<br>• 移动第N个盘子到目标柱子<br>• 将N-1个盘子从中间柱子移动到目标柱<br>子<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        movePlate(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">movePlate</span><span class="params">(<span class="keyword">int</span> size, List&lt;Integer&gt; start, List&lt;Integer&gt; auxiliary,List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 只剩⼀一个盘⼦子时，直接从第⼀一个柱⼦子移动到第三个柱⼦子 即可</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数主功能：移动n-1个盘⼦子，移动第n个盘⼦子，移动n-1个盘⼦子</span></span><br><span class="line">        <span class="comment">// 等价关系式 f(n , A , B , C)=f(n-1,A,C,B)+M(A,C)+f(n-1, B,A,C)</span></span><br><span class="line">        <span class="comment">// 将 n-1 个盘⼦子，从 第⼀一个柱⼦子 移动到 第⼆二个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,start,target,auxiliary);</span><br><span class="line">        <span class="comment">// 将第 n个盘⼦子，从 第⼀一个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 再将 n-1 个盘⼦子，从 第⼆二个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,auxiliary,start,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：通过</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.4 MB, 在所有 Java 提交中击败了45.35%的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="递归" scheme="www.rickzhang.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>你应该懂的排序</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-14T01:45:13.000Z</published>
    <updated>2021-07-14T13:57:16.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[begin] &lt; arr[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[begin];</span><br><span class="line">                arr[begin] = arr[begin - <span class="number">1</span>];</span><br><span class="line">                arr[begin - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n2)</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[j] &gt; temp)) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) arr[j] =temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡排序&quot;&gt;&lt;/a&gt;1. 冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    
    <category term="排序" scheme="www.rickzhang.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>springcloud使用</title>
    <link href="www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/"/>
    <id>www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-10T06:29:39.000Z</published>
    <updated>2021-07-13T06:22:08.158Z</updated>
    
    <content type="html"><![CDATA[<p>nacos注册中心<br>使用方式：<br>1.为项目导入alibaba的依赖<br>2.导入nacos的依赖<br>3.在main加注解<br>4.需要给每一个微服务加上自己的名字</p><p>想要远程调用别的服务<br>1.引入open-feign<br>2.编写一个接口，告诉springcloud这个接口需要调用远程服务<br>3.声明接口的每一个方法都是调用哪个远程服务的那个请求<br>4.开启远程调用功能<br>远程调用注意版本：<a href="https://blog.csdn.net/weixin_45729934/article/details/110310119" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45729934/article/details/110310119</a></p><p>nacos作为配置中心<br>1.导入pom：nacos config starter<br>2.创建配置文件：bootstrap.properties<br>3.在127.0.0.1：8848中创建配置文件：项目名.properties<br>4.在controller加上@RefreshScope—-动态刷新</p><p>API网关</p><p>vue<br>初始化：npm init -y<br>安装vue依赖：npm install vue</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nacos注册中心&lt;br&gt;使用方式：&lt;br&gt;1.为项目导入alibaba的依赖&lt;br&gt;2.导入nacos的依赖&lt;br&gt;3.在main加注解&lt;br&gt;4.需要给每一个微服务加上自己的名字&lt;/p&gt;
&lt;p&gt;想要远程调用别的服务&lt;br&gt;1.引入open-feign&lt;br&gt;2.编写一个</summary>
      
    
    
    
    
    <category term="springcloud" scheme="www.rickzhang.cn/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>线程学习笔记</title>
    <link href="www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T02:52:48.000Z</published>
    <updated>2021-07-13T06:23:17.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享学"><a href="#享学" class="headerlink" title="享学"></a>享学</h2><ol><li>安装完成的软件叫应用程序 是死的<br>打开后叫进程 操作系统分配资源的最小单位<br>进程与进程之间是相互独立<br>线程是CPU调度的最小单位<br>线程必须依赖于进程<br>进程里允许有多个线程<br>线程之间可以共享进程的资源<br>CPU多核数与线程的关系：一对一关系<br>RR调度  CPU时间片轮转机制<br>并行与并发：<br>并行：可以同时运行的任务数<br>并发：讨论并发无法脱离时间，可以交替执行不用任务，<br>创建线程的方式有两种，在官方JDK源码Thread里有写</li><li>继承Thread</li><li>实现Runnable接口<br>两者有什么区别呢？<br>Thread是线程的抽象，Runnable是对任务的抽象<br>stop()方法为什么不建议使用？<br>可能会导致线程所占用的资源不会正常的释放<br>interrupt()是对线程进行中断<br>isInterrupted()是判断线程是否被中断<br>interrupted() 把标志位改为false<br>JDK线程是协作式，不是抢占式</li><li>实现接口Runnable的线程如何进行中断？<br>Thread.currentThread().isInterrupted()</li></ol><h2 id="马士兵"><a href="#马士兵" class="headerlink" title="马士兵"></a>马士兵</h2><p>什么是进程？<br>什么是线程？<br>什么是qia</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;享学&quot;&gt;&lt;a href=&quot;#享学&quot; class=&quot;headerlink&quot; title=&quot;享学&quot;&gt;&lt;/a&gt;享学&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装完成的软件叫应用程序 是死的&lt;br&gt;打开后叫进程 操作系统分配资源的最小单位&lt;br&gt;进程与进程之间是相互独立&lt;br&gt;线程是C</summary>
      
    
    
    
    
    <category term="线程" scheme="www.rickzhang.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从3.无重复字符的最长子串到哈希表</title>
    <link href="www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-07-07T15:06:29.000Z</published>
    <updated>2021-07-07T15:24:32.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>从题目的无重复可以引入哈希表，因为哈希表对于查找是比较快的<br>先定义一个数组来存储</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, <span class="comment">//最长不重复子串的长度</span></span><br><span class="line">        left = <span class="number">0</span>, <span class="comment">//子串最左端字符索引</span></span><br><span class="line">        right = <span class="number">0</span>; <span class="comment">//子串最右端字符索引</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">//ASCII码</span></span><br><span class="line">        <span class="comment">//赋初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历字符串的所有字符</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s.charAt(right);<span class="comment">//取出right对应索引的值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start0 = arr[c] + <span class="number">1</span>;</span><br><span class="line">                left = left &gt;= start0 ? left : start0;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[c] = right;</span><br><span class="line">            <span class="keyword">int</span> size = right + <span class="number">1</span> - left;</span><br><span class="line">            res = res &gt; size ? res : size;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了83.64%的用户</p><p><strong>复杂度分析</strong><br>时间复杂度:O(n)<br>空间复杂度:O(1)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;br&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="www.rickzhang.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>80.删除有序数组中的重复项Ⅱ</title>
    <link href="www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/"/>
    <id>www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/</id>
    <published>2021-07-02T15:40:30.000Z</published>
    <updated>2021-07-02T16:27:44.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>相对于26题目，对了一个条件，只需要多了一个步伐便可<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;<span class="comment">//数组长度</span></span><br><span class="line">    <span class="comment">//如果数组长度小于等于2，则不用进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow-<span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：<br>0 ms<br>, 在所有 Java 提交中击败了<br>100.00%<br>的用户</p><p>内存消耗：<br>38.4 MB<br>, 在所有 Java 提交中击败了<br>79.48%<br>的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。&lt;/p</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>27.移除元素</title>
    <link href="www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-02T11:50:24.000Z</published>
    <updated>2021-07-02T12:14:00.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>目标是如果数组中与给定值相等，等将后面的元素往前移动，如果不相等，则继续遍历数组，定义两个指针，一个(left)负责遍历原数组，一个(right)负责与目标值target比较，若right与val相等，则right++,如果不相等,<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">//原数组指针</span></span><br><span class="line">    <span class="comment">//right为遍历指针,负责与val比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; length; right++) &#123;</span><br><span class="line">        <span class="comment">//如果right与val不相等，则将right赋值给left，left往前走</span></span><br><span class="line">        <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%<br>的用户</p><p>内存消耗：36.8 MB, 在所有 Java 提交中击败了85.41%的用户</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>从26.删除有序数组中的重复项谈到双指针</title>
    <link href="www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-07-02T09:39:50.000Z</published>
    <updated>2021-07-02T11:49:17.591Z</updated>
    
    <content type="html"><![CDATA[<p>老规矩，先上题目</p><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历数组，依次比较相邻的元素(i和i+1),如果两者不相同则向后遍历，i++;相同则后面的所有元素前移一位；每遇到重复的元素，数组长度缩减1</li><li>双指针解法：定义两个指针分别指向目标位和待移动元素位，可定义初始目标位为0，待移动元素位为1，比较两个指针对应的数据，相等则目标位不变，待移动位加1；不相等则目标位加1，待移动元素复制到目标位，待移动位加1<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="comment">//依次比较相邻的元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//不同则往后遍历</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果相同，则后面所有元素往前移动一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">1</span> ; j++) &#123;</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次遇到重复元素，数组长度缩减1</span></span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：通过</li></ul><p>执行用时：435 ms, 在所有 Java 提交中击败了5.03%的用户</p><p>内存消耗：39.3 MB, 在所有 Java 提交中击败了99.50%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n2)<br>空间复杂度:O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个指针</span></span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>; <span class="comment">//目标位指针</span></span><br><span class="line">    <span class="comment">//i待移动位指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果不相等，则目标位加1，但是如果目标位跟移动位相等了，则跳过赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (nums[target] != nums[i]) &#123;</span><br><span class="line">            <span class="comment">//target++;</span></span><br><span class="line">            <span class="keyword">if</span> (++target != i) &#123;</span><br><span class="line">                nums[target] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：1 ms, 在所有 Java 提交中击败了83.23%的用户</p><p>内存消耗：39.9 MB, 在所有 Java 提交中击败了88.46%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n)</p><p>空间复杂度:O(1)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本道题主要使用了双指针，那为什么会使用到双指针呢？就是当我们需要两个数据，并且两者是按照一定的规律同步变化时，我们就可以选择双指针，相对于暴力解法，少了移动元素时所需要的时间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老规矩，先上题目&lt;/p&gt;
&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>java集合总结</title>
    <link href="www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-29T01:58:24.000Z</published>
    <updated>2021-07-20T01:43:58.522Z</updated>
    
    <content type="html"><![CDATA[<p>紧密结构:数组<br>跳转结构:链表<br>集合大纲</p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><p>collection是一个接口，主要提供了以下方法：<br>增加:add(E e) addAll(Collection&lt;? extends E&gt; c)<br>删除:clear() remove(Object o)<br>修改:<br>查看:iterator() size()<br>判断:contains(Object o) equals(Object o) isEmpty()<br>对于接口,不能直接创建对向,只能利用实现类来创建对象,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection col = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>集合有一个特点:只能存放引用数据类型的数据,不能是基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">col.add(<span class="number">18</span>); <span class="comment">//基本类型会进行自动装箱</span></span><br><span class="line">col.add(<span class="number">19</span>);</span><br><span class="line">col.add(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//iterator使用</span></span><br><span class="line">Iterator it = col.iterator();<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;紧密结构:数组&lt;br&gt;跳转结构:链表&lt;br&gt;集合大纲&lt;/p&gt;
&lt;h2 id=&quot;1-Collection&quot;&gt;&lt;a href=&quot;#1-Collection&quot; class=&quot;headerlink&quot; title=&quot;1. Collection&quot;&gt;&lt;/a&gt;1. Collection&lt;/</summary>
      
    
    
    
    
    <category term="java基础" scheme="www.rickzhang.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>谈到环，你应该想到啥</title>
    <link href="www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/"/>
    <id>www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/</id>
    <published>2021-06-27T15:42:33.000Z</published>
    <updated>2021-06-27T15:42:33.626Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-27T13:54:16.000Z</published>
    <updated>2021-06-27T14:12:22.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现跨域的标识"><a href="#出现跨域的标识" class="headerlink" title="出现跨域的标识"></a>出现跨域的标识</h2><p>当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</p><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。<br>常见的跨域：<br><img src="http://images.xiaozhang233.top/image.png" alt="images"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置  Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略，设置响应头中的参数来允许跨域域请求:</p><ol><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Origin 标识允许跨域的请求有哪些<br>例如在java开发中常常这样来解决：</li><li>在POM文件中引入依赖和在web.xml中配置跨域filter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入POM文件 --&gt;</span><br><span class="line">&lt;!-- 解决跨域问题所需依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 在web.xml中配置跨域filter --&gt;</span><br><span class="line">&lt;!--配置跨域过滤器--&gt;</span><br><span class="line">  &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">thetransactioncompany</span>.<span class="title">cors</span>.<span class="title">CORSFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">corsFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>直接导入java类来进行解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(CorsConfiguration.ALL)</span><br><span class="line">                .allowedMethods(CorsConfiguration.ALL)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 1小时内不需要再预检（发OPTIONS请求）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;出现跨域的标识&quot;&gt;&lt;a href=&quot;#出现跨域的标识&quot; class=&quot;headerlink&quot; title=&quot;出现跨域的标识&quot;&gt;&lt;/a&gt;出现跨域的标识&lt;/h2&gt;&lt;p&gt;当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Cont</summary>
      
    
    
    
    
    <category term="前后端交互" scheme="www.rickzhang.cn/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-27-141-环形链表</title>
    <link href="www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/06/27/2021-06-27-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-27T13:42:07.000Z</published>
    <updated>2021-06-27T15:41:38.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><strong>示例</strong><br><img src="http://images.xiaozhang233.top/03.jpg" alt="images"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>思路1:遇到环形可以联想到从头遍历到尾，总会有那么几个点会重复遇到，那证明它就含有环了(暴力解法)。<br>思路2：可以转化为追及问题，可以利用快慢链表来实现</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义数组记录已访问的节点</span></span><br><span class="line">    ListNode[] array = <span class="keyword">new</span> ListNode[<span class="number">10000</span>];</span><br><span class="line">    <span class="comment">//2.遍历链表的每个节点</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++&gt;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == head) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                array[i] = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.若next指针为null，则说明方法结束，返回false;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：<br>127 ms<br>, 在所有 Java 提交中击败了<br>5.24%<br>的用户</p><p>内存消耗：<br>38.6 MB<br>, 在所有 Java 提交中击败了<br>99.47%<br>的用户<br><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.先判断head是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.定义快慢指针</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="comment">//3.遍历链表：并且设定两个链表的步长</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//4.当且仅当快慢指针重合：有环，操作结束</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.如果不相等，则继续前进</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：<br>0 ms<br>, 在所有 Java 提交中击败了<br>100.00%<br>的用户</p><p>内存消耗：<br>39.7 MB<br>, 在所有 Java 提交中击败了<br>27.29%<br>的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;br&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 </summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021-06-26-02-两数相加</title>
    <link href="www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>www.rickzhang.cn/2021/06/26/2021-06-26-02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-06-26T02:49:53.000Z</published>
    <updated>2021-06-26T05:26:26.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因： <span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历两个链表使用数学思维分别转成证书，再进行求和，最后将所求和转为链表(不可取)</li><li>升级版：利用数学思维遍历两个链表，将对应的节点数值进行相加，将结果插入新链表尾部，若数值大于10，则进位，将进位加到下一个节点。<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p = l1, q = l2; <span class="comment">//原链表的两个遍历指针</span></span><br><span class="line">        ListNode resultHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//结果链表的头结点head</span></span><br><span class="line">        ListNode curr = resultHead; <span class="comment">//结果链表的遍历指针，代表当前操作的节点</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点值，如果链表较短，已无节点，取0</span></span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y; <span class="comment">//对应位置节点数值相加</span></span><br><span class="line">            carry = sum / <span class="number">10</span>; <span class="comment">//求进位值，即对10求整</span></span><br><span class="line">            <span class="keyword">int</span> num = sum % <span class="number">10</span>;<span class="comment">//存放到新链表的数值</span></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(num);<span class="comment">//创建新节点存储值</span></span><br><span class="line">            curr = curr.next; <span class="comment">//结果链表向后移动</span></span><br><span class="line">            <span class="comment">//遍历原链表</span></span><br><span class="line">            p = p == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line">            q = q == <span class="keyword">null</span> ? q : q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4.复杂度分析"></a>4.复杂度分析</h2></li><li>时间复杂度：O(max(m,n))</li><li>空间复杂度：O(max(m,n))</li></ul><p><img src="http://qval5nqsx.hn-bkt.clouddn.com/02.jpg" alt="images"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021.06.25|933.最近的请求次数</title>
    <link href="www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/"/>
    <id>www.rickzhang.cn/2021/06/25/2021-06-25-933-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</id>
    <published>2021-06-25T01:23:24.000Z</published>
    <updated>2021-06-26T02:55:41.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时<br>间（毫秒），返回从 3000 毫秒前（时间范围：[t - 3000, t] ）到现在的 ping 数<br>• 保证每次对 ping 的调用都使用比之前更大的 t 值，1 &lt;= t &lt;= 10^9<br>• 每个测试用例会使用严格递增的 t 值来调用ping，最多调用 10000 次 ping<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inputs = [[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>该题目可以这样理解，最终是要求请求的次数，每次一个请求过来，如果符合([t-3000],t),则记录次数，不符合则不记录，则可以用队列来实现</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q; <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.add(t); <span class="comment">//将请求添加到队列</span></span><br><span class="line">        <span class="comment">//对请求进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (q.peek() &lt; t - <span class="number">3000</span>&gt;) &#123;</span><br><span class="line">            q.poll(); <span class="comment">//不符合则出列</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size(); <span class="comment">//返回总的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂度分析："><a href="#4-复杂度分析：" class="headerlink" title="4. 复杂度分析："></a>4. 复杂度分析：</h2><ul><li>时间复杂度：O(1) //每次添加删除都是O(1)</li><li>空间复杂度: O(1) //最多保留3001个</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;最近的请求次数：在 RecentCounter 类中有一个方法：ping(int t)，t 代表某个时&lt;br</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>小型项目部署篇</title>
    <link href="www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/06/24/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%AF%87/</id>
    <published>2021-06-24T14:56:19.000Z</published>
    <updated>2021-06-25T01:49:46.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字</strong> 域名 服务器 nginx 代理</p><h4 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h4><ul><li>推荐网站：华为云、阿里云（本人选择）<h4 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a>服务器购买</h4></li><li>推荐网站：华为云、阿里云（本人选择）<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line">service nginx start &#x2F;&#x2F;启动nginx</span><br><span class="line">systemctl enable nginx &#x2F;&#x2F;开启自启</span><br></pre></td></tr></table></figure>安装完nginx后，它的配置文件在/etc/nginx中，打开/etc/nginx/nginx.conf,将user nginx改为user root，保存，不然后续部署项目可能会遇到问题。<h4 id="前端项目打包"><a href="#前端项目打包" class="headerlink" title="前端项目打包"></a>前端项目打包</h4></li><li>打包上传到服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署前端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1000</span>;  <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki.xiaozhang233.top; <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">alias</span> /root/wiki/web/; <span class="comment">#项目路径</span></span><br><span class="line">    <span class="attribute">index</span> index.html; <span class="comment">#首页访问 </span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure><h4 id="JAVA后端项目打包"><a href="#JAVA后端项目打包" class="headerlink" title="JAVA后端项目打包"></a>JAVA后端项目打包</h4></li><li>后端项目打包完成后上传至服务器</li><li>利用nginx进行部署，打开/etc/nginx/conf.d,新建一个文件，来部署后端项目，文件以.conf为后缀即可，添加以下内容<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">1001</span>; <span class="comment">#监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> wiki_server.xiaozhang233.top;  <span class="comment">#域名</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8880;<span class="comment">#反向代理，端口号为后端项目运行的端口号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加后执行<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure></li><li>启动JAVA后端项目<br>选择自己想要的目录，创建deploy.sh文件,文件内容为：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "publish----------"</span><br><span class="line"></span><br><span class="line">process_id=`ps -ef | grep edu-zhang.jar | grep -v grep |awk '&#123;print $2&#125;'`</span><br><span class="line">if [ $process_id ] ; then</span><br><span class="line">sudo kill -9 $process_id</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">nohup java -jar -Dspring.profiles.active=prod ~/edu-zhang/edu-zhang.jar &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "end publish"</span><br></pre></td></tr></table></figure></li><li><em>~/edu-zhang/edu-zhang.jar*</em>为自己项目的地址</li><li>执行：sh deploy.sh 启动项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt; 域名 服务器 nginx 代理&lt;/p&gt;
&lt;h4 id=&quot;域名购买&quot;&gt;&lt;a href=&quot;#域名购买&quot; class=&quot;headerlink&quot; title=&quot;域名购买&quot;&gt;&lt;/a&gt;域名购买&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;推荐网站：华为云、阿里云</summary>
      
    
    
    
    
    <category term="项目部署" scheme="www.rickzhang.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>

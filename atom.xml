<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangRuZhang</title>
  
  
  <link href="www.rickzhang.cn/atom.xml" rel="self"/>
  
  <link href="www.rickzhang.cn/"/>
  <updated>2021-07-31T14:31:50.385Z</updated>
  <id>www.rickzhang.cn/</id>
  
  <author>
    <name>Zhang Ru Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么迟迟没有读懂数据结构与算法</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9F%E8%BF%9F%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%87%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-31T14:31:50.000Z</published>
    <updated>2021-07-31T14:31:50.385Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>你该懂的设计模式</title>
    <link href="www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>www.rickzhang.cn/2021/07/31/%E4%BD%A0%E8%AF%A5%E6%87%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-31T14:31:07.000Z</published>
    <updated>2021-07-31T14:31:07.622Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小小刷题之旅</title>
    <link href="www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/"/>
    <id>www.rickzhang.cn/2021/07/23/%E5%B0%8F%E5%B0%8F%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/</id>
    <published>2021-07-23T05:28:13.000Z</published>
    <updated>2021-07-23T05:28:13.538Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法养成篇</title>
    <link href="www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%BB%E6%88%90%E7%AF%87/</id>
    <published>2021-07-23T05:27:53.000Z</published>
    <updated>2021-07-26T02:55:32.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评估算法优劣的核心指标是什么"><a href="#评估算法优劣的核心指标是什么" class="headerlink" title="评估算法优劣的核心指标是什么?"></a>评估算法优劣的核心指标是什么?</h2><ul><li>时间复杂度(流程决定)</li><li>额外空间复杂度(流程决定)</li><li>常数项时间(实现细节决定)</li></ul><h2 id="何为常数时间的操作"><a href="#何为常数时间的操作" class="headerlink" title="何为常数时间的操作?"></a>何为常数时间的操作?</h2><p>如果一个操作的执行时间不以具体样本量为转移,每次执行时间都是固定时间,那这样的操作称为常数时间的操作.<br>常见的常数时间的操作:</p><ul><li>常见的算术运算(+ - * / %等)</li><li>常见的位运算(&gt;&gt;(带符号右移) &gt;&gt;&gt;(不带符号右移) | &amp; ^) (&gt;&gt;与&gt;&gt;&gt;的区别 &gt;&gt;右移后符号位补上原来的符号位,&gt;&gt;&gt;则无论正负,都是补0,两者移动后总体位数不变)</li><li>赋值,比较,自增,自减等操作</li><li>数组寻址操作<br>总之执行时间固定的操作都是常数时间的操作<h2 id="如何确定算法流程的总操作数量与样本数量之间的表达式关系"><a href="#如何确定算法流程的总操作数量与样本数量之间的表达式关系" class="headerlink" title="如何确定算法流程的总操作数量与样本数量之间的表达式关系?"></a>如何确定算法流程的总操作数量与样本数量之间的表达式关系?</h2></li><li>想象该算法流程所处理的数据状况,要按照最差情况来</li><li>把整个流程彻底拆分为一个个基本动作,保证每个动作都是常数时间的操作</li><li>如果数据量为N,看看基本动作的数量和N是什么关系.<h2 id="如何确定算法流程的时间复杂度"><a href="#如何确定算法流程的时间复杂度" class="headerlink" title="如何确定算法流程的时间复杂度"></a>如何确定算法流程的时间复杂度</h2>当完成了表达式的建立,只要把最高阶项留下即可,低阶项都去掉,高阶项的系数也去掉,记为:O(忽略掉系数的高阶项)<br>N<em>2 == N&lt;&lt;1<br>N/2 == N&gt;&gt;1<br>N</em>2+1 == (N&lt;&lt;1)|1</li></ul><h2 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h2><p>对于时间复杂度,一个只剩下一个最高阶项,那这样的意义何在呢?</p><ul><li><p>当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。</p></li><li><p>它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。</p><p><strong>注意:</strong>我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。</p><p>难道同样时间复杂度的流程，在实际运行时候就一样的好吗？</p><p>当然不是。</p><p>时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</p><p>作为输入参数的空间，不算额外空间。<br>作为输出结果的空间，也不算额外空间。</p><p>因为这些都是必要的、和现实目标有关的。所以都不算。</p><p>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>算法思路</strong>:将索引为0的下标假设成最小值,与往后的数值比较,如果比索引为0的数值小,则交换位置,一轮下来则实现索引为0的下标为当前最小值,继续往后选择索引为1的下标,重复此操作<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//设置最小值在哪个位置上</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>算法思路:</strong> 假设数组的长度为N,从[0,N-1]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-1位置;从[0,N-2]范围上,比较arr[0]和arr[1],谁大谁来到1位置,之后arr[1]和arr[2]进行比较,谁大谁来到2位置,依次往后比较,谁大谁来到N-2位置…</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr,i, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思路:</strong> 想让arr[0<del>0]上有序，这个范围只有一个数，当然是有序的。<br>想让arr[0</del>1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。<br>…<br>想让arr[0<del>i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。<br>最后一步，想让arr[0</del>N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol><li><p>在一个有序数组中，找某个数是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);<span class="comment">//==mid = (L+R)/2</span></span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>在一个有序数组中，找&gt;=某个数最左侧的位置 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在arr上,找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>在一个有序数组中，找&lt;=某个数最右侧的位置 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a>异或运算符</h2><p><strong>用法</strong>: 无进位相加–&gt;即相同为0,不同为1</p><p><strong>性质:</strong> </p><ul><li><p>0^N == N  N^N ==0</p></li><li><p>满足交换律和结合律</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><h4 id="不用额外变量交换两个数"><a href="#不用额外变量交换两个数" class="headerlink" title="不用额外变量交换两个数"></a>不用额外变量交换两个数</h4><p><strong>代码实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">1000</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h4 id="怎么把一个int类型的数，提取出最右侧的1来"><a href="#怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="怎么把一个int类型的数，提取出最右侧的1来"></a>怎么把一个int类型的数，提取出最右侧的1来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ero = 任意数;</span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"><a href="#一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数"></a>一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eor = a ^ b</span></span><br><span class="line"><span class="comment">// eor != 0</span></span><br><span class="line"><span class="comment">// eor必然有一个位置上是1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>); <span class="comment">// 提取出最右的1</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">onlyOne ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(onlyOne + <span class="string">" "</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单链表与双链表"><a href="#单链表与双链表" class="headerlink" title="单链表与双链表"></a>单链表与双链表</h3><h4 id="1-单链表和双链表如何反转"><a href="#1-单链表和双链表如何反转" class="headerlink" title="1.单链表和双链表如何反转"></a>1.单链表和双链表如何反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = pre;</span><br><span class="line">head.last = next;</span><br><span class="line">pre = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-把给定值都删除"><a href="#2-把给定值都删除" class="headerlink" title="2.把给定值都删除"></a>2.把给定值都删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head.value != num) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">Node pre = head;</span><br><span class="line">Node cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur.value == num) &#123;</span><br><span class="line">pre.next = cur.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评估算法优劣的核心指标是什么&quot;&gt;&lt;a href=&quot;#评估算法优劣的核心指标是什么&quot; class=&quot;headerlink&quot; title=&quot;评估算法优劣的核心指标是什么?&quot;&gt;&lt;/a&gt;评估算法优劣的核心指标是什么?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间复杂度(流程决定)&lt;/l</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="www.rickzhang.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试题</title>
    <link href="www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/07/22/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-07-22T02:43:35.000Z</published>
    <updated>2021-07-23T02:14:35.725Z</updated>
    
    
    
    
    
    <category term="面试" scheme="www.rickzhang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java多线程篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/</id>
    <published>2021-07-20T01:43:21.000Z</published>
    <updated>2021-07-20T03:45:59.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序运行资源分配的最小单位</p><p>线程则是CPU调度的最小单位,且必须依赖进程而存在<br>线程无处不在</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发:指应用能够交替执行不同的任务</p><p>并行:指应用能够同时执行不同的任务.</p><p><strong>两者区别:</strong> 一个是交替执行,一个是同时执行.</p><h2 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h2><ol><li>充分利用CPU资源</li><li>加快响应用户的时间</li><li>可以使代码模块化,异步化,简单化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程是程序运行资源分配的最小单位&lt;/p&gt;
&lt;p&gt;线程则是CPU调度的最小单位,且必须依赖进程而存在&lt;br&gt;线程无处不</summary>
      
    
    
    
    
    <category term="多线程" scheme="www.rickzhang.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础篇</title>
    <link href="www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>www.rickzhang.cn/2021/07/20/java%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-07-20T01:42:51.000Z</published>
    <updated>2021-07-20T01:42:51.574Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从排序矩阵查找到分治算法</title>
    <link href="www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>www.rickzhang.cn/2021/07/18/%E4%BB%8E%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE%E5%88%B0%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-18T14:59:32.000Z</published>
    <updated>2021-07-19T02:52:20.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>维护一个行指针和一个列指针，利用分治算法，从右上角元素出发，比较目标元素与当前数值</p><ul><li>如果当前元素等于目标值，则返回true</li><li>如果当前元素小于目标值，则当前元素左侧的元素都会小于目标值，指针下移动</li><li>如果当前元素大于目标值，则当前元素右下方都会大于目标值，指针左移</li><li>如果指针在矩阵外，返回false  <h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length; <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始位置假设在右上角位置，定义一个行指针和一个列指针</span></span><br><span class="line">        <span class="keyword">int</span> currentRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentColumn = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentColumn &gt;= <span class="number">0</span> &amp;&amp; currentRow &lt; m) &#123;</span><br><span class="line">            <span class="comment">//当前元素等于目标值，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果当前元素小于目标值，则列指针下移</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[currentRow][currentColumn] &lt; target) &#123;</span><br><span class="line">                currentRow++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果当前元素大于目标值，则列指针左移</span></span><br><span class="line">                currentColumn--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度:O(m+n)<br>空间复杂度:O(1)</li></ul><p>执行结果：<br>通过</p><p>执行用时：<br>5 ms<br>, 在所有 Java 提交中击败了<br>98.91%<br>的用户</p><p>内存消耗：<br>43.9 MB<br>, 在所有 Java 提交中击败了<br>52.11%<br>的用户</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>该题目使用双指针，并且利用了分治思维，那什么是分治算法呢？</p><ul><li>把复杂的问题分成两个或者更多的相同或者相似的子问题，直到子问题可直接求解，原问题的解即子问题的解的合并<br>分治法解题的一般步骤:</li><li>分解:将要解决的问题划分为若干规模较小的同类问题</li><li>求解:递归地求解各个子问题，当子问题划分得足够小时，用较简单的方法解决</li><li>合并:按原问题的要求，将子问题的解逐层合并构成原问题的解<h2 id="5-扩展题目"><a href="#5-扩展题目" class="headerlink" title="5. 扩展题目"></a>5. 扩展题目</h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。&lt;/p&gt;
&lt;h2 id=&quot;2-解题思路</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="分治" scheme="www.rickzhang.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于JDK8的更新,你应该知道</title>
    <link href="www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/"/>
    <id>www.rickzhang.cn/2021/07/15/%E5%85%B3%E4%BA%8EJDK8%E7%9A%84%E6%9B%B4%E6%96%B0-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</id>
    <published>2021-07-15T15:04:24.000Z</published>
    <updated>2021-07-15T15:04:24.157Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>从汉诺塔问题谈到递归</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BB%8E%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E8%B0%88%E5%88%B0%E9%80%92%E5%BD%92/</id>
    <published>2021-07-14T10:19:19.000Z</published>
    <updated>2021-07-15T02:15:08.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>根据美国一学者提出的两步操作法：1.按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，2.把另外两根柱子上可以移动的圆盘移动到新的柱子上<br>• 把非空柱子上的圆盘移动到空柱子上<br>• 当两根柱子都非空时，移动较小的圆盘<br>重复以上操作即可，对于N层汉诺塔，有以下思路：• 如果我们能将上面的N-1层移动到B上<br>• 把N层移动到C，再把B上N-1层移动到C上就可以解决问题了<br>• 问题变为如何解决N-1层汉诺塔的移动问题<br>• 继续思考一直到N-1等于1时，我们可以直接将1层汉诺塔移动目的位置<br>可以选择递归来实现：<br>• 递归函数主功能<br>• 移动N-1个盘子到中间柱子<br>• 移动第N个盘子到目标柱子<br>• 将N-1个盘子从中间柱子移动到目标柱<br>子<br><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        movePlate(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">movePlate</span><span class="params">(<span class="keyword">int</span> size, List&lt;Integer&gt; start, List&lt;Integer&gt; auxiliary,List&lt;Integer&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 只剩⼀一个盘⼦子时，直接从第⼀一个柱⼦子移动到第三个柱⼦子 即可</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数主功能：移动n-1个盘⼦子，移动第n个盘⼦子，移动n-1个盘⼦子</span></span><br><span class="line">        <span class="comment">// 等价关系式 f(n , A , B , C)=f(n-1,A,C,B)+M(A,C)+f(n-1, B,A,C)</span></span><br><span class="line">        <span class="comment">// 将 n-1 个盘⼦子，从 第⼀一个柱⼦子 移动到 第⼆二个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,start,target,auxiliary);</span><br><span class="line">        <span class="comment">// 将第 n个盘⼦子，从 第⼀一个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        target.add(start.remove(start.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 再将 n-1 个盘⼦子，从 第⼆二个柱⼦子 移动到 第三个柱⼦子</span></span><br><span class="line">        movePlate(size-<span class="number">1</span>,auxiliary,start,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：通过</p><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.4 MB, 在所有 Java 提交中击败了45.35%的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h2&gt;&lt;p&gt;在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="递归" scheme="www.rickzhang.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>你应该懂的排序</title>
    <link href="www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>www.rickzhang.cn/2021/07/14/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-14T01:45:13.000Z</published>
    <updated>2021-07-14T13:57:16.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[begin] &lt; arr[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[begin];</span><br><span class="line">                arr[begin] = arr[begin - <span class="number">1</span>];</span><br><span class="line">                arr[begin - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n2)</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[j] &gt; temp)) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) arr[j] =temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡排序&quot;&gt;&lt;/a&gt;1. 冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    
    <category term="排序" scheme="www.rickzhang.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>springcloud使用</title>
    <link href="www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/"/>
    <id>www.rickzhang.cn/2021/07/10/springcloud%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-10T06:29:39.000Z</published>
    <updated>2021-07-13T06:22:08.158Z</updated>
    
    <content type="html"><![CDATA[<p>nacos注册中心<br>使用方式：<br>1.为项目导入alibaba的依赖<br>2.导入nacos的依赖<br>3.在main加注解<br>4.需要给每一个微服务加上自己的名字</p><p>想要远程调用别的服务<br>1.引入open-feign<br>2.编写一个接口，告诉springcloud这个接口需要调用远程服务<br>3.声明接口的每一个方法都是调用哪个远程服务的那个请求<br>4.开启远程调用功能<br>远程调用注意版本：<a href="https://blog.csdn.net/weixin_45729934/article/details/110310119" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45729934/article/details/110310119</a></p><p>nacos作为配置中心<br>1.导入pom：nacos config starter<br>2.创建配置文件：bootstrap.properties<br>3.在127.0.0.1：8848中创建配置文件：项目名.properties<br>4.在controller加上@RefreshScope—-动态刷新</p><p>API网关</p><p>vue<br>初始化：npm init -y<br>安装vue依赖：npm install vue</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nacos注册中心&lt;br&gt;使用方式：&lt;br&gt;1.为项目导入alibaba的依赖&lt;br&gt;2.导入nacos的依赖&lt;br&gt;3.在main加注解&lt;br&gt;4.需要给每一个微服务加上自己的名字&lt;/p&gt;
&lt;p&gt;想要远程调用别的服务&lt;br&gt;1.引入open-feign&lt;br&gt;2.编写一个</summary>
      
    
    
    
    
    <category term="springcloud" scheme="www.rickzhang.cn/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>线程学习笔记</title>
    <link href="www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>www.rickzhang.cn/2021/07/09/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T02:52:48.000Z</published>
    <updated>2021-07-13T06:23:17.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享学"><a href="#享学" class="headerlink" title="享学"></a>享学</h2><ol><li>安装完成的软件叫应用程序 是死的<br>打开后叫进程 操作系统分配资源的最小单位<br>进程与进程之间是相互独立<br>线程是CPU调度的最小单位<br>线程必须依赖于进程<br>进程里允许有多个线程<br>线程之间可以共享进程的资源<br>CPU多核数与线程的关系：一对一关系<br>RR调度  CPU时间片轮转机制<br>并行与并发：<br>并行：可以同时运行的任务数<br>并发：讨论并发无法脱离时间，可以交替执行不用任务，<br>创建线程的方式有两种，在官方JDK源码Thread里有写</li><li>继承Thread</li><li>实现Runnable接口<br>两者有什么区别呢？<br>Thread是线程的抽象，Runnable是对任务的抽象<br>stop()方法为什么不建议使用？<br>可能会导致线程所占用的资源不会正常的释放<br>interrupt()是对线程进行中断<br>isInterrupted()是判断线程是否被中断<br>interrupted() 把标志位改为false<br>JDK线程是协作式，不是抢占式</li><li>实现接口Runnable的线程如何进行中断？<br>Thread.currentThread().isInterrupted()</li></ol><h2 id="马士兵"><a href="#马士兵" class="headerlink" title="马士兵"></a>马士兵</h2><p>什么是进程？<br>什么是线程？<br>什么是qia</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;享学&quot;&gt;&lt;a href=&quot;#享学&quot; class=&quot;headerlink&quot; title=&quot;享学&quot;&gt;&lt;/a&gt;享学&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装完成的软件叫应用程序 是死的&lt;br&gt;打开后叫进程 操作系统分配资源的最小单位&lt;br&gt;进程与进程之间是相互独立&lt;br&gt;线程是C</summary>
      
    
    
    
    
    <category term="线程" scheme="www.rickzhang.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从3.无重复字符的最长子串到哈希表</title>
    <link href="www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>www.rickzhang.cn/2021/07/07/%E4%BB%8E3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%88%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-07-07T15:06:29.000Z</published>
    <updated>2021-07-07T15:24:32.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>从题目的无重复可以引入哈希表，因为哈希表对于查找是比较快的<br>先定义一个数组来存储</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, <span class="comment">//最长不重复子串的长度</span></span><br><span class="line">        left = <span class="number">0</span>, <span class="comment">//子串最左端字符索引</span></span><br><span class="line">        right = <span class="number">0</span>; <span class="comment">//子串最右端字符索引</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">//ASCII码</span></span><br><span class="line">        <span class="comment">//赋初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历字符串的所有字符</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s.charAt(right);<span class="comment">//取出right对应索引的值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[c] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start0 = arr[c] + <span class="number">1</span>;</span><br><span class="line">                left = left &gt;= start0 ? left : start0;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[c] = right;</span><br><span class="line">            <span class="keyword">int</span> size = right + <span class="number">1</span> - left;</span><br><span class="line">            res = res &gt; size ? res : size;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了83.64%的用户</p><p><strong>复杂度分析</strong><br>时间复杂度:O(n)<br>空间复杂度:O(1)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;br&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="www.rickzhang.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>80.删除有序数组中的重复项Ⅱ</title>
    <link href="www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/"/>
    <id>www.rickzhang.cn/2021/07/02/80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1/</id>
    <published>2021-07-02T15:40:30.000Z</published>
    <updated>2021-07-02T16:27:44.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>相对于26题目，对了一个条件，只需要多了一个步伐便可<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;<span class="comment">//数组长度</span></span><br><span class="line">    <span class="comment">//如果数组长度小于等于2，则不用进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow-<span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：<br>0 ms<br>, 在所有 Java 提交中击败了<br>100.00%<br>的用户</p><p>内存消耗：<br>38.4 MB<br>, 在所有 Java 提交中击败了<br>79.48%<br>的用户</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。&lt;/p</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>27.移除元素</title>
    <link href="www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>www.rickzhang.cn/2021/07/02/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-02T11:50:24.000Z</published>
    <updated>2021-07-02T12:14:00.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>目标是如果数组中与给定值相等，等将后面的元素往前移动，如果不相等，则继续遍历数组，定义两个指针，一个(left)负责遍历原数组，一个(right)负责与目标值target比较，若right与val相等，则right++,如果不相等,<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">//原数组指针</span></span><br><span class="line">    <span class="comment">//right为遍历指针,负责与val比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; length; right++) &#123;</span><br><span class="line">        <span class="comment">//如果right与val不相等，则将right赋值给left，left往前走</span></span><br><span class="line">        <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：<br>通过</li></ul><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%<br>的用户</p><p>内存消耗：36.8 MB, 在所有 Java 提交中击败了85.41%的用户</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>从26.删除有序数组中的重复项谈到双指针</title>
    <link href="www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>www.rickzhang.cn/2021/07/02/%E4%BB%8E26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E8%B0%88%E5%88%B0%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-07-02T09:39:50.000Z</published>
    <updated>2021-07-02T11:49:17.591Z</updated>
    
    <content type="html"><![CDATA[<p>老规矩，先上题目</p><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ul><li>暴力解法：遍历数组，依次比较相邻的元素(i和i+1),如果两者不相同则向后遍历，i++;相同则后面的所有元素前移一位；每遇到重复的元素，数组长度缩减1</li><li>双指针解法：定义两个指针分别指向目标位和待移动元素位，可定义初始目标位为0，待移动元素位为1，比较两个指针对应的数据，相等则目标位不变，待移动位加1；不相等则目标位加1，待移动元素复制到目标位，待移动位加1<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="comment">//依次比较相邻的元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//不同则往后遍历</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果相同，则后面所有元素往前移动一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">1</span> ; j++) &#123;</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次遇到重复元素，数组长度缩减1</span></span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果：通过</li></ul><p>执行用时：435 ms, 在所有 Java 提交中击败了5.03%的用户</p><p>内存消耗：39.3 MB, 在所有 Java 提交中击败了99.50%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n2)<br>空间复杂度:O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个指针</span></span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>; <span class="comment">//目标位指针</span></span><br><span class="line">    <span class="comment">//i待移动位指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果不相等，则目标位加1，但是如果目标位跟移动位相等了，则跳过赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (nums[target] != nums[i]) &#123;</span><br><span class="line">            <span class="comment">//target++;</span></span><br><span class="line">            <span class="keyword">if</span> (++target != i) &#123;</span><br><span class="line">                nums[target] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>通过</p><p>执行用时：1 ms, 在所有 Java 提交中击败了83.23%的用户</p><p>内存消耗：39.9 MB, 在所有 Java 提交中击败了88.46%的用户</p><p><strong>复杂度分析</strong></p><p>时间复杂度:O(n)</p><p>空间复杂度:O(1)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本道题主要使用了双指针，那为什么会使用到双指针呢？就是当我们需要两个数据，并且两者是按照一定的规律同步变化时，我们就可以选择双指针，相对于暴力解法，少了移动元素时所需要的时间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老规矩，先上题目&lt;/p&gt;
&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目&quot;&gt;&lt;/a&gt;1. 题目&lt;/h2&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，</summary>
      
    
    
    
    
    <category term="Leetcode" scheme="www.rickzhang.cn/tags/Leetcode/"/>
    
    <category term="双指针" scheme="www.rickzhang.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>java集合总结</title>
    <link href="www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>www.rickzhang.cn/2021/06/29/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-29T01:58:24.000Z</published>
    <updated>2021-07-23T05:28:26.637Z</updated>
    
    <content type="html"><![CDATA[<p>紧密结构:数组<br>跳转结构:链表<br>集合大纲</p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><p>collection是一个接口，主要提供了以下方法：<br>增加:add(E e) addAll(Collection&lt;? extends E&gt; c)<br>删除:clear() remove(Object o)<br>修改:<br>查看:iterator() size()<br>判断:contains(Object o) equals(Object o) isEmpty()<br>对于接口,不能直接创建对向,只能利用实现类来创建对象,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection col = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>集合有一个特点:只能存放引用数据类型的数据,不能是基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">col.add(<span class="number">18</span>); <span class="comment">//基本类型会进行自动装箱</span></span><br><span class="line">col.add(<span class="number">19</span>);</span><br><span class="line">col.add(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//iterator使用</span></span><br><span class="line">Iterator it = col.iterator();<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList<br>1.7源码:底层数组,在调用构造器的时候,数组长度初始化10,扩容的时候扩展为原数组的1.5倍<br>1.8源码:底层数组,在调用构造器的时候,次成数组为{},在调用add方法后底层数组才重新赋值为新数组,新数组的长度为10,这样做的好处是节省了内存,在add后才创建长度为10的数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;紧密结构:数组&lt;br&gt;跳转结构:链表&lt;br&gt;集合大纲&lt;/p&gt;
&lt;h2 id=&quot;1-Collection&quot;&gt;&lt;a href=&quot;#1-Collection&quot; class=&quot;headerlink&quot; title=&quot;1. Collection&quot;&gt;&lt;/a&gt;1. Collection&lt;/</summary>
      
    
    
    
    
    <category term="java基础" scheme="www.rickzhang.cn/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>谈到环，你应该想到啥</title>
    <link href="www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/"/>
    <id>www.rickzhang.cn/2021/06/27/%E8%B0%88%E5%88%B0%E7%8E%AF%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%83%B3%E5%88%B0%E5%95%A5/</id>
    <published>2021-06-27T15:42:33.000Z</published>
    <updated>2021-06-27T15:42:33.626Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>www.rickzhang.cn/2021/06/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-27T13:54:16.000Z</published>
    <updated>2021-06-27T14:12:22.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现跨域的标识"><a href="#出现跨域的标识" class="headerlink" title="出现跨域的标识"></a>出现跨域的标识</h2><p>当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Control-Allow-Origin’标头（跨域请求失败）</p><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p>跨域是指通过JS在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，只要协议、域名、端口有任何一个不同，都被当作是不同的域,浏览器就不允许跨域请求。<br>常见的跨域：<br><img src="http://images.xiaozhang233.top/image.png" alt="images"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置  Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略，设置响应头中的参数来允许跨域域请求:</p><ol><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Origin 标识允许跨域的请求有哪些<br>例如在java开发中常常这样来解决：</li><li>在POM文件中引入依赖和在web.xml中配置跨域filter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入POM文件 --&gt;</span><br><span class="line">&lt;!-- 解决跨域问题所需依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 在web.xml中配置跨域filter --&gt;</span><br><span class="line">&lt;!--配置跨域过滤器--&gt;</span><br><span class="line">  &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">thetransactioncompany</span>.<span class="title">cors</span>.<span class="title">CORSFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">corsFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>直接导入java类来进行解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(CorsConfiguration.ALL)</span><br><span class="line">                .allowedMethods(CorsConfiguration.ALL)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 1小时内不需要再预检（发OPTIONS请求）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;出现跨域的标识&quot;&gt;&lt;a href=&quot;#出现跨域的标识&quot; class=&quot;headerlink&quot; title=&quot;出现跨域的标识&quot;&gt;&lt;/a&gt;出现跨域的标识&lt;/h2&gt;&lt;p&gt;当我们在前端项目中，向后端发送请求获取数据的时候，会出现：请求的资源上没有’ Access-Cont</summary>
      
    
    
    
    
    <category term="前后端交互" scheme="www.rickzhang.cn/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
</feed>
